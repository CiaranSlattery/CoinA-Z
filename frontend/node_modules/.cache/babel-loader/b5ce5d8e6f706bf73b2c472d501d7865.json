{"ast":null,"code":"/**\r\n * DevExtreme (esm/ui/number_box/number_box.caret.js)\r\n * Version: 21.2.5\r\n * Build date: Mon Jan 17 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { fitIntoRange } from \"../../core/utils/math\";\nimport { escapeRegExp } from \"../../core/utils/common\";\nimport number from \"../../localization/number\";\nimport { getRealSeparatorIndex, getNthOccurrence, splitByIndex } from \"./utils\";\nexport var getCaretBoundaries = function (text, format) {\n  if (\"string\" === typeof format) {\n    var signParts = format.split(\";\");\n    var sign = number.getSign(text, format);\n    signParts[1] = signParts[1] || \"-\" + signParts[0];\n    format = signParts[sign < 0 ? 1 : 0];\n    format = (str = format, str.replace(/'([^']*)'/g, str => str.split(\"\").map(() => \" \").join(\"\").substr(2)));\n    var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\n    var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\n    return {\n      start: prefixStubLength,\n      end: text.length - postfixStubLength\n    };\n  } else {\n    return {\n      start: 0,\n      end: text.length\n    };\n  }\n\n  var str;\n};\n\nvar _getDigitCountBeforeIndex = function (index, text) {\n  var decimalSeparator = number.getDecimalSeparator();\n  var regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\");\n  var textBeforePosition = text.slice(0, index);\n  return textBeforePosition.replace(regExp, \"\").length;\n};\n\nvar _reverseText = function (text) {\n  return text.split(\"\").reverse().join(\"\");\n};\n\nvar _getDigitPositionByIndex = function (digitIndex, text) {\n  if (!digitIndex) {\n    return -1;\n  }\n\n  var regExp = /[0-9]/g;\n  var counter = 1;\n  var index = null;\n  var result = regExp.exec(text);\n\n  while (result) {\n    index = result.index;\n\n    if (counter >= digitIndex) {\n      return index;\n    }\n\n    counter++;\n    result = regExp.exec(text);\n  }\n\n  return null === index ? text.length : index;\n};\n\nvar _trimNonNumericCharsFromEnd = function (text) {\n  return text.replace(/[^0-9e]+$/, \"\");\n};\n\nexport var getCaretWithOffset = function (caret, offset) {\n  if (void 0 === caret.start) {\n    caret = {\n      start: caret,\n      end: caret\n    };\n  }\n\n  return {\n    start: caret.start + offset,\n    end: caret.end + offset\n  };\n};\nexport var getCaretAfterFormat = function (text, formatted, caret, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var point = number.getDecimalSeparator();\n  var isSeparatorBasedText = isSeparatorBasedString(text);\n  var realSeparatorOccurrenceIndex = getRealSeparatorIndex(format).occurrence;\n  var pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);\n  var newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);\n  var textParts = splitByIndex(text, pointPosition);\n  var formattedParts = splitByIndex(formatted, newPointPosition);\n  var isCaretOnFloat = -1 !== pointPosition && caret.start > pointPosition;\n\n  if (isCaretOnFloat) {\n    var relativeIndex = caret.start - pointPosition - 1;\n\n    var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\n\n    var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\n    return getCaretInBoundaries(newPosition, formatted, format);\n  } else {\n    var formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);\n\n    var positionFromEnd = textParts[0].length - caret.start;\n\n    var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\n\n    var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));\n\n    var newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);\n    return getCaretInBoundaries(newPositionFromBegin, formatted, format);\n  }\n};\n\nfunction isSeparatorBasedString(text) {\n  return 1 === text.length && !!text.match(/^[,.][0-9]*$/g);\n}\n\nexport var isCaretInBoundaries = function (caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretInBoundaries(caret, text, format);\n  return caret.start >= boundaries.start && caret.end <= boundaries.end;\n};\nexport function getCaretInBoundaries(caret, text, format) {\n  caret = getCaretWithOffset(caret, 0);\n  var boundaries = getCaretBoundaries(text, format);\n  var adjustedCaret = {\n    start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\n    end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\n  };\n  return adjustedCaret;\n}\nexport var getCaretOffset = function (previousText, newText, format) {\n  var previousBoundaries = getCaretBoundaries(previousText, format);\n  var newBoundaries = getCaretBoundaries(newText, format);\n  return newBoundaries.start - previousBoundaries.start;\n};","map":{"version":3,"sources":["C:/Users/ciara/OneDrive - GMIT/Coin A-Z Test Repo/frontend/node_modules/devextreme/esm/ui/number_box/number_box.caret.js"],"names":["fitIntoRange","escapeRegExp","number","getRealSeparatorIndex","getNthOccurrence","splitByIndex","getCaretBoundaries","text","format","signParts","split","sign","getSign","str","replace","map","join","substr","prefixStubLength","exec","length","postfixStubLength","start","end","_getDigitCountBeforeIndex","index","decimalSeparator","getDecimalSeparator","regExp","RegExp","textBeforePosition","slice","_reverseText","reverse","_getDigitPositionByIndex","digitIndex","counter","result","_trimNonNumericCharsFromEnd","getCaretWithOffset","caret","offset","getCaretAfterFormat","formatted","point","isSeparatorBasedText","isSeparatorBasedString","realSeparatorOccurrenceIndex","occurrence","pointPosition","newPointPosition","textParts","formattedParts","isCaretOnFloat","relativeIndex","digitsBefore","newPosition","getCaretInBoundaries","formattedIntPart","positionFromEnd","digitsFromEnd","newPositionFromEnd","newPositionFromBegin","match","isCaretInBoundaries","boundaries","adjustedCaret","getCaretOffset","previousText","newText","previousBoundaries","newBoundaries"],"mappings":"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","sourcesContent":["/**\r\n * DevExtreme (esm/ui/number_box/number_box.caret.js)\r\n * Version: 21.2.5\r\n * Build date: Mon Jan 17 2022\r\n *\r\n * Copyright (c) 2012 - 2022 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\r\nimport {\r\n    fitIntoRange\r\n} from \"../../core/utils/math\";\r\nimport {\r\n    escapeRegExp\r\n} from \"../../core/utils/common\";\r\nimport number from \"../../localization/number\";\r\nimport {\r\n    getRealSeparatorIndex,\r\n    getNthOccurrence,\r\n    splitByIndex\r\n} from \"./utils\";\r\nexport var getCaretBoundaries = function(text, format) {\r\n    if (\"string\" === typeof format) {\r\n        var signParts = format.split(\";\");\r\n        var sign = number.getSign(text, format);\r\n        signParts[1] = signParts[1] || \"-\" + signParts[0];\r\n        format = signParts[sign < 0 ? 1 : 0];\r\n        format = (str = format, str.replace(/'([^']*)'/g, str => str.split(\"\").map(() => \" \").join(\"\").substr(2)));\r\n        var prefixStubLength = /^[^#0.,]*/.exec(format)[0].length;\r\n        var postfixStubLength = /[^#0.,]*$/.exec(format)[0].length;\r\n        return {\r\n            start: prefixStubLength,\r\n            end: text.length - postfixStubLength\r\n        }\r\n    } else {\r\n        return {\r\n            start: 0,\r\n            end: text.length\r\n        }\r\n    }\r\n    var str\r\n};\r\nvar _getDigitCountBeforeIndex = function(index, text) {\r\n    var decimalSeparator = number.getDecimalSeparator();\r\n    var regExp = new RegExp(\"[^0-9\" + escapeRegExp(decimalSeparator) + \"]\", \"g\");\r\n    var textBeforePosition = text.slice(0, index);\r\n    return textBeforePosition.replace(regExp, \"\").length\r\n};\r\nvar _reverseText = function(text) {\r\n    return text.split(\"\").reverse().join(\"\")\r\n};\r\nvar _getDigitPositionByIndex = function(digitIndex, text) {\r\n    if (!digitIndex) {\r\n        return -1\r\n    }\r\n    var regExp = /[0-9]/g;\r\n    var counter = 1;\r\n    var index = null;\r\n    var result = regExp.exec(text);\r\n    while (result) {\r\n        index = result.index;\r\n        if (counter >= digitIndex) {\r\n            return index\r\n        }\r\n        counter++;\r\n        result = regExp.exec(text)\r\n    }\r\n    return null === index ? text.length : index\r\n};\r\nvar _trimNonNumericCharsFromEnd = function(text) {\r\n    return text.replace(/[^0-9e]+$/, \"\")\r\n};\r\nexport var getCaretWithOffset = function(caret, offset) {\r\n    if (void 0 === caret.start) {\r\n        caret = {\r\n            start: caret,\r\n            end: caret\r\n        }\r\n    }\r\n    return {\r\n        start: caret.start + offset,\r\n        end: caret.end + offset\r\n    }\r\n};\r\nexport var getCaretAfterFormat = function(text, formatted, caret, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    var point = number.getDecimalSeparator();\r\n    var isSeparatorBasedText = isSeparatorBasedString(text);\r\n    var realSeparatorOccurrenceIndex = getRealSeparatorIndex(format).occurrence;\r\n    var pointPosition = isSeparatorBasedText ? 0 : getNthOccurrence(text, point, realSeparatorOccurrenceIndex);\r\n    var newPointPosition = getNthOccurrence(formatted, point, realSeparatorOccurrenceIndex);\r\n    var textParts = splitByIndex(text, pointPosition);\r\n    var formattedParts = splitByIndex(formatted, newPointPosition);\r\n    var isCaretOnFloat = -1 !== pointPosition && caret.start > pointPosition;\r\n    if (isCaretOnFloat) {\r\n        var relativeIndex = caret.start - pointPosition - 1;\r\n        var digitsBefore = _getDigitCountBeforeIndex(relativeIndex, textParts[1]);\r\n        var newPosition = formattedParts[1] ? newPointPosition + 1 + _getDigitPositionByIndex(digitsBefore, formattedParts[1]) + 1 : formatted.length;\r\n        return getCaretInBoundaries(newPosition, formatted, format)\r\n    } else {\r\n        var formattedIntPart = _trimNonNumericCharsFromEnd(formattedParts[0]);\r\n        var positionFromEnd = textParts[0].length - caret.start;\r\n        var digitsFromEnd = _getDigitCountBeforeIndex(positionFromEnd, _reverseText(textParts[0]));\r\n        var newPositionFromEnd = _getDigitPositionByIndex(digitsFromEnd, _reverseText(formattedIntPart));\r\n        var newPositionFromBegin = formattedIntPart.length - (newPositionFromEnd + 1);\r\n        return getCaretInBoundaries(newPositionFromBegin, formatted, format)\r\n    }\r\n};\r\n\r\nfunction isSeparatorBasedString(text) {\r\n    return 1 === text.length && !!text.match(/^[,.][0-9]*$/g)\r\n}\r\nexport var isCaretInBoundaries = function(caret, text, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    var boundaries = getCaretInBoundaries(caret, text, format);\r\n    return caret.start >= boundaries.start && caret.end <= boundaries.end\r\n};\r\nexport function getCaretInBoundaries(caret, text, format) {\r\n    caret = getCaretWithOffset(caret, 0);\r\n    var boundaries = getCaretBoundaries(text, format);\r\n    var adjustedCaret = {\r\n        start: fitIntoRange(caret.start, boundaries.start, boundaries.end),\r\n        end: fitIntoRange(caret.end, boundaries.start, boundaries.end)\r\n    };\r\n    return adjustedCaret\r\n}\r\nexport var getCaretOffset = function(previousText, newText, format) {\r\n    var previousBoundaries = getCaretBoundaries(previousText, format);\r\n    var newBoundaries = getCaretBoundaries(newText, format);\r\n    return newBoundaries.start - previousBoundaries.start\r\n};\r\n"]},"metadata":{},"sourceType":"module"}