{"ast":null,"code":"var isArray = Array.isArray;\n\nfunction isStringOrNumber(o) {\n  var type = typeof o;\n  return type === 'string' || type === 'number';\n}\n\nfunction isNullOrUndef(o) {\n  return o === void 0 || o === null;\n}\n\nfunction isInvalid(o) {\n  return o === null || o === false || o === true || o === void 0;\n}\n\nfunction isFunction(o) {\n  return typeof o === 'function';\n}\n\nfunction isString(o) {\n  return typeof o === 'string';\n}\n\nfunction isNumber(o) {\n  return typeof o === 'number';\n}\n\nfunction isNull(o) {\n  return o === null;\n}\n\nfunction isUndefined(o) {\n  return o === void 0;\n}\n\nfunction combineFrom(first, second) {\n  var out = {};\n\n  if (first) {\n    for (var key in first) {\n      out[key] = first[key];\n    }\n  }\n\n  if (second) {\n    for (var key$1 in second) {\n      out[key$1] = second[key$1];\n    }\n  }\n\n  return out;\n}\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\n\n\nfunction linkEvent(data, event) {\n  if (isFunction(event)) {\n    return {\n      data: data,\n      event: event\n    };\n  }\n\n  return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n} // object.event should always be function, otherwise its badly created object.\n\n\nfunction isLinkEventObject(o) {\n  return !isNull(o) && typeof o === 'object';\n} // We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\n\n\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\n\nfunction normalizeEventName(name) {\n  return name.substr(2).toLowerCase();\n}\n\nfunction appendChild(parentDOM, dom) {\n  parentDOM.appendChild(dom);\n}\n\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n  if (isNull(nextNode)) {\n    appendChild(parentDOM, newNode);\n  } else {\n    parentDOM.insertBefore(newNode, nextNode);\n  }\n}\n\nfunction documentCreateElement(tag, isSVG) {\n  if (isSVG) {\n    return document.createElementNS('http://www.w3.org/2000/svg', tag);\n  }\n\n  return document.createElement(tag);\n}\n\nfunction replaceChild(parentDOM, newDom, lastDom) {\n  parentDOM.replaceChild(newDom, lastDom);\n}\n\nfunction removeChild(parentDOM, childNode) {\n  parentDOM.removeChild(childNode);\n}\n\nfunction callAll(arrayFn) {\n  for (var i = 0; i < arrayFn.length; i++) {\n    arrayFn[i]();\n  }\n}\n\nfunction findChildVNode(vNode, startEdge, flags) {\n  var children = vNode.children;\n\n  if (flags & 4\n  /* ComponentClass */\n  ) {\n    return children.$LI;\n  }\n\n  if (flags & 8192\n  /* Fragment */\n  ) {\n    return vNode.childFlags === 2\n    /* HasVNodeChildren */\n    ? children : children[startEdge ? 0 : children.length - 1];\n  }\n\n  return children;\n}\n\nfunction findDOMfromVNode(vNode, startEdge) {\n  var flags;\n\n  while (vNode) {\n    flags = vNode.flags;\n\n    if (flags & 2033\n    /* DOMRef */\n    ) {\n      return vNode.dom;\n    }\n\n    vNode = findChildVNode(vNode, startEdge, flags);\n  }\n\n  return null;\n}\n\nfunction removeVNodeDOM(vNode, parentDOM) {\n  do {\n    var flags = vNode.flags;\n\n    if (flags & 2033\n    /* DOMRef */\n    ) {\n      removeChild(parentDOM, vNode.dom);\n      return;\n    }\n\n    var children = vNode.children;\n\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      vNode = children.$LI;\n    }\n\n    if (flags & 8\n    /* ComponentFunction */\n    ) {\n      vNode = children;\n    }\n\n    if (flags & 8192\n    /* Fragment */\n    ) {\n      if (vNode.childFlags === 2\n      /* HasVNodeChildren */\n      ) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          removeVNodeDOM(children[i], parentDOM);\n        }\n\n        return;\n      }\n    }\n  } while (vNode);\n}\n\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n  do {\n    var flags = vNode.flags;\n\n    if (flags & 2033\n    /* DOMRef */\n    ) {\n      insertOrAppend(parentDOM, vNode.dom, nextNode);\n      return;\n    }\n\n    var children = vNode.children;\n\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      vNode = children.$LI;\n    }\n\n    if (flags & 8\n    /* ComponentFunction */\n    ) {\n      vNode = children;\n    }\n\n    if (flags & 8192\n    /* Fragment */\n    ) {\n      if (vNode.childFlags === 2\n      /* HasVNodeChildren */\n      ) {\n        vNode = children;\n      } else {\n        for (var i = 0, len = children.length; i < len; ++i) {\n          moveVNodeDOM(children[i], parentDOM, nextNode);\n        }\n\n        return;\n      }\n    }\n  } while (vNode);\n}\n\nfunction createDerivedState(instance, nextProps, state) {\n  if (instance.constructor.getDerivedStateFromProps) {\n    return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n  }\n\n  return state;\n}\n\nvar renderCheck = {\n  v: false\n};\nvar options = {\n  componentComparator: null,\n  createVNode: null,\n  renderComplete: null\n};\n\nfunction setTextContent(dom, children) {\n  dom.textContent = children;\n} // Calling this function assumes, nextValue is linkEvent\n\n\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n  return isLinkEventObject(lastValue) && lastValue.event === nextValue.event && lastValue.data === nextValue.data;\n}\n\nfunction mergeUnsetProperties(to, from) {\n  for (var propName in from) {\n    if (isUndefined(to[propName])) {\n      to[propName] = from[propName];\n    }\n  }\n\n  return to;\n}\n\nfunction safeCall1(method, arg1) {\n  return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\n\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n  this.childFlags = childFlags;\n  this.children = children;\n  this.className = className;\n  this.dom = null;\n  this.flags = flags;\n  this.key = key === void 0 ? null : key;\n  this.props = props === void 0 ? null : props;\n  this.ref = ref === void 0 ? null : ref;\n  this.type = type;\n}\n\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n  var childFlag = childFlags === void 0 ? 1\n  /* HasInvalidChildren */\n  : childFlags;\n  var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n\n  if (childFlag === 0\n  /* UnknownChildren */\n  ) {\n    normalizeChildren(vNode, vNode.children);\n  }\n\n  return vNode;\n}\n\nfunction mergeDefaultHooks(flags, type, ref) {\n  if (flags & 4\n  /* ComponentClass */\n  ) {\n    return ref;\n  }\n\n  var defaultHooks = (flags & 32768\n  /* ForwardRef */\n  ? type.render : type).defaultHooks;\n\n  if (isNullOrUndef(defaultHooks)) {\n    return ref;\n  }\n\n  if (isNullOrUndef(ref)) {\n    return defaultHooks;\n  }\n\n  return mergeUnsetProperties(ref, defaultHooks);\n}\n\nfunction mergeDefaultProps(flags, type, props) {\n  // set default props\n  var defaultProps = (flags & 32768\n  /* ForwardRef */\n  ? type.render : type).defaultProps;\n\n  if (isNullOrUndef(defaultProps)) {\n    return props;\n  }\n\n  if (isNullOrUndef(props)) {\n    return combineFrom(defaultProps, null);\n  }\n\n  return mergeUnsetProperties(props, defaultProps);\n}\n\nfunction resolveComponentFlags(flags, type) {\n  if (flags & 12\n  /* ComponentKnown */\n  ) {\n    return flags;\n  }\n\n  if (type.prototype && type.prototype.render) {\n    return 4\n    /* ComponentClass */\n    ;\n  }\n\n  if (type.render) {\n    return 32776\n    /* ForwardRefComponent */\n    ;\n  }\n\n  return 8\n  /* ComponentFunction */\n  ;\n}\n\nfunction createComponentVNode(flags, type, props, key, ref) {\n  flags = resolveComponentFlags(flags, type);\n  var vNode = new V(1\n  /* HasInvalidChildren */\n  , null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n\n  if (options.createVNode) {\n    options.createVNode(vNode);\n  }\n\n  return vNode;\n}\n\nfunction createTextVNode(text, key) {\n  return new V(1\n  /* HasInvalidChildren */\n  , isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16\n  /* Text */\n  , key, null, null, null);\n}\n\nfunction createFragment(children, childFlags, key) {\n  var fragment = createVNode(8192\n  /* Fragment */\n  , 8192\n  /* Fragment */\n  , null, children, childFlags, null, key, null);\n\n  switch (fragment.childFlags) {\n    case 1\n    /* HasInvalidChildren */\n    :\n      fragment.children = createVoidVNode();\n      fragment.childFlags = 2\n      /* HasVNodeChildren */\n      ;\n      break;\n\n    case 16\n    /* HasTextChildren */\n    :\n      fragment.children = [createTextVNode(children)];\n      fragment.childFlags = 4\n      /* HasNonKeyedChildren */\n      ;\n      break;\n  }\n\n  return fragment;\n}\n\nfunction normalizeProps(vNode) {\n  var props = vNode.props;\n\n  if (props) {\n    var flags = vNode.flags;\n\n    if (flags & 481\n    /* Element */\n    ) {\n      if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n        normalizeChildren(vNode, props.children);\n      }\n\n      if (props.className !== void 0) {\n        if (isNullOrUndef(vNode.className)) {\n          vNode.className = props.className || null;\n        }\n\n        props.className = undefined;\n      }\n    }\n\n    if (props.key !== void 0) {\n      vNode.key = props.key;\n      props.key = undefined;\n    }\n\n    if (props.ref !== void 0) {\n      if (flags & 8\n      /* ComponentFunction */\n      ) {\n        vNode.ref = combineFrom(vNode.ref, props.ref);\n      } else {\n        vNode.ref = props.ref;\n      }\n\n      props.ref = undefined;\n    }\n  }\n\n  return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\n\n\nfunction cloneFragment(vNodeToClone) {\n  var oldChildren = vNodeToClone.children;\n  var childFlags = vNodeToClone.childFlags;\n  return createFragment(childFlags === 2\n  /* HasVNodeChildren */\n  ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\n\nfunction directClone(vNodeToClone) {\n  var flags = vNodeToClone.flags & -16385\n  /* ClearInUse */\n  ;\n  var props = vNodeToClone.props;\n\n  if (flags & 14\n  /* Component */\n  ) {\n    if (!isNull(props)) {\n      var propsToClone = props;\n      props = {};\n\n      for (var key in propsToClone) {\n        props[key] = propsToClone[key];\n      }\n    }\n  }\n\n  if ((flags & 8192\n  /* Fragment */\n  ) === 0) {\n    return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n  }\n\n  return cloneFragment(vNodeToClone);\n}\n\nfunction createVoidVNode() {\n  return createTextVNode('', null);\n}\n\nfunction createPortal(children, container) {\n  var normalizedRoot = normalizeRoot(children);\n  return createVNode(1024\n  /* Portal */\n  , 1024\n  /* Portal */\n  , null, normalizedRoot, 0\n  /* UnknownChildren */\n  , null, normalizedRoot.key, container);\n}\n\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n  for (var len = nodes.length; index < len; index++) {\n    var n = nodes[index];\n\n    if (!isInvalid(n)) {\n      var newKey = currentKey + keyPrefix + index;\n\n      if (isArray(n)) {\n        _normalizeVNodes(n, result, 0, newKey);\n      } else {\n        if (isStringOrNumber(n)) {\n          n = createTextVNode(n, newKey);\n        } else {\n          var oldKey = n.key;\n          var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n\n          if (n.flags & 81920\n          /* InUseOrNormalized */\n          || isPrefixedKey) {\n            n = directClone(n);\n          }\n\n          n.flags |= 65536\n          /* Normalized */\n          ;\n\n          if (!isPrefixedKey) {\n            if (isNull(oldKey)) {\n              n.key = newKey;\n            } else {\n              n.key = currentKey + oldKey;\n            }\n          } else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n            n.key = currentKey + oldKey;\n          }\n        }\n\n        result.push(n);\n      }\n    }\n  }\n}\n\nfunction getFlagsForElementVnode(type) {\n  switch (type) {\n    case 'svg':\n      return 32\n      /* SvgElement */\n      ;\n\n    case 'input':\n      return 64\n      /* InputElement */\n      ;\n\n    case 'select':\n      return 256\n      /* SelectElement */\n      ;\n\n    case 'textarea':\n      return 128\n      /* TextareaElement */\n      ;\n\n    case Fragment:\n      return 8192\n      /* Fragment */\n      ;\n\n    default:\n      return 1\n      /* HtmlElement */\n      ;\n  }\n}\n\nfunction normalizeChildren(vNode, children) {\n  var newChildren;\n  var newChildFlags = 1\n  /* HasInvalidChildren */\n  ; // Don't change children to match strict equal (===) true in patching\n\n  if (isInvalid(children)) {\n    newChildren = children;\n  } else if (isStringOrNumber(children)) {\n    newChildFlags = 16\n    /* HasTextChildren */\n    ;\n    newChildren = children;\n  } else if (isArray(children)) {\n    var len = children.length;\n\n    for (var i = 0; i < len; ++i) {\n      var n = children[i];\n\n      if (isInvalid(n) || isArray(n)) {\n        newChildren = newChildren || children.slice(0, i);\n\n        _normalizeVNodes(children, newChildren, i, '');\n\n        break;\n      } else if (isStringOrNumber(n)) {\n        newChildren = newChildren || children.slice(0, i);\n        newChildren.push(createTextVNode(n, keyPrefix + i));\n      } else {\n        var key = n.key;\n        var needsCloning = (n.flags & 81920\n        /* InUseOrNormalized */\n        ) > 0;\n        var isNullKey = isNull(key);\n        var isPrefixed = isString(key) && key[0] === keyPrefix;\n\n        if (needsCloning || isNullKey || isPrefixed) {\n          newChildren = newChildren || children.slice(0, i);\n\n          if (needsCloning || isPrefixed) {\n            n = directClone(n);\n          }\n\n          if (isNullKey || isPrefixed) {\n            n.key = keyPrefix + i;\n          }\n\n          newChildren.push(n);\n        } else if (newChildren) {\n          newChildren.push(n);\n        }\n\n        n.flags |= 65536\n        /* Normalized */\n        ;\n      }\n    }\n\n    newChildren = newChildren || children;\n\n    if (newChildren.length === 0) {\n      newChildFlags = 1\n      /* HasInvalidChildren */\n      ;\n    } else {\n      newChildFlags = 8\n      /* HasKeyedChildren */\n      ;\n    }\n  } else {\n    newChildren = children;\n    newChildren.flags |= 65536\n    /* Normalized */\n    ;\n\n    if (children.flags & 81920\n    /* InUseOrNormalized */\n    ) {\n      newChildren = directClone(children);\n    }\n\n    newChildFlags = 2\n    /* HasVNodeChildren */\n    ;\n  }\n\n  vNode.children = newChildren;\n  vNode.childFlags = newChildFlags;\n  return vNode;\n}\n\nfunction normalizeRoot(input) {\n  if (isInvalid(input) || isStringOrNumber(input)) {\n    return createTextVNode(input, null);\n  }\n\n  if (isArray(input)) {\n    return createFragment(input, 0\n    /* UnknownChildren */\n    , null);\n  }\n\n  return input.flags & 16384\n  /* InUse */\n  ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n  'xlink:actuate': xlinkNS,\n  'xlink:arcrole': xlinkNS,\n  'xlink:href': xlinkNS,\n  'xlink:role': xlinkNS,\n  'xlink:show': xlinkNS,\n  'xlink:title': xlinkNS,\n  'xlink:type': xlinkNS,\n  'xml:base': xmlNS,\n  'xml:lang': xmlNS,\n  'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n  return {\n    onClick: v,\n    onDblClick: v,\n    onFocusIn: v,\n    onFocusOut: v,\n    onKeyDown: v,\n    onKeyPress: v,\n    onKeyUp: v,\n    onMouseDown: v,\n    onMouseMove: v,\n    onMouseUp: v,\n    onTouchEnd: v,\n    onTouchMove: v,\n    onTouchStart: v\n  };\n}\n\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\n\nfunction updateOrAddSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n\n  if (!eventsObject) {\n    eventsObject = dom.$EV = getDelegatedEventObject(null);\n  }\n\n  if (!eventsObject[name]) {\n    if (++attachedEventCounts[name] === 1) {\n      attachedEvents[name] = attachEventToDocument(name);\n    }\n  }\n\n  return eventsObject;\n}\n\nfunction unmountSyntheticEvent(name, dom) {\n  var eventsObject = dom.$EV;\n\n  if (eventsObject && eventsObject[name]) {\n    if (--attachedEventCounts[name] === 0) {\n      document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n      attachedEvents[name] = null;\n    }\n\n    eventsObject[name] = null;\n  }\n}\n\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n  if (isFunction(nextEvent)) {\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else if (isLinkEventObject(nextEvent)) {\n    if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n      return;\n    }\n\n    updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n  } else {\n    unmountSyntheticEvent(name, dom);\n  }\n} // When browsers fully support event.composedPath we could loop it through instead of using parentNode property\n\n\nfunction getTargetNode(event) {\n  return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\n\nfunction dispatchEvents(event, isClick, name, eventData) {\n  var dom = getTargetNode(event);\n\n  do {\n    // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n    // because the event listener is on document.body\n    // Don't process clicks on disabled elements\n    if (isClick && dom.disabled) {\n      return;\n    }\n\n    var eventsObject = dom.$EV;\n\n    if (eventsObject) {\n      var currentEvent = eventsObject[name];\n\n      if (currentEvent) {\n        // linkEvent object\n        eventData.dom = dom;\n        currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n\n        if (event.cancelBubble) {\n          return;\n        }\n      }\n    }\n\n    dom = dom.parentNode;\n  } while (!isNull(dom));\n}\n\nfunction stopPropagation() {\n  this.cancelBubble = true;\n\n  if (!this.immediatePropagationStopped) {\n    this.stopImmediatePropagation();\n  }\n}\n\nfunction isDefaultPrevented() {\n  return this.defaultPrevented;\n}\n\nfunction isPropagationStopped() {\n  return this.cancelBubble;\n}\n\nfunction extendEventProperties(event) {\n  // Event data needs to be object to save reference to currentTarget getter\n  var eventData = {\n    dom: document\n  };\n  event.isDefaultPrevented = isDefaultPrevented;\n  event.isPropagationStopped = isPropagationStopped;\n  event.stopPropagation = stopPropagation;\n  Object.defineProperty(event, 'currentTarget', {\n    configurable: true,\n    get: function get() {\n      return eventData.dom;\n    }\n  });\n  return eventData;\n}\n\nfunction rootClickEvent(name) {\n  return function (event) {\n    if (event.button !== 0) {\n      // Firefox incorrectly triggers click event for mid/right mouse buttons.\n      // This bug has been active for 17 years.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n      event.stopPropagation();\n      return;\n    }\n\n    dispatchEvents(event, true, name, extendEventProperties(event));\n  };\n}\n\nfunction rootEvent(name) {\n  return function (event) {\n    dispatchEvents(event, false, name, extendEventProperties(event));\n  };\n}\n\nfunction attachEventToDocument(name) {\n  var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n  document.addEventListener(normalizeEventName(name), attachedEvent);\n  return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n  var tempdom = document.createElement('i');\n  tempdom.innerHTML = innerHTML;\n  return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n  if (props[methodName]) {\n    var listener = props[methodName];\n\n    if (listener.event) {\n      listener.event(listener.data, e);\n    } else {\n      listener(e);\n    }\n  } else {\n    var nativeListenerName = methodName.toLowerCase();\n\n    if (props[nativeListenerName]) {\n      props[nativeListenerName](e);\n    }\n  }\n}\n\nfunction createWrappedFunction(methodName, applyValue) {\n  var fnMethod = function (e) {\n    var vNode = this.$V; // If vNode is gone by the time event fires, no-op\n\n    if (!vNode) {\n      return;\n    }\n\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n\n    if (isString(methodName)) {\n      triggerEventListener(props, methodName, e);\n    } else {\n      for (var i = 0; i < methodName.length; ++i) {\n        triggerEventListener(props, methodName[i], e);\n      }\n    }\n\n    if (isFunction(applyValue)) {\n      var newVNode = this.$V;\n      var newProps = newVNode.props || EMPTY_OBJ;\n      applyValue(newProps, dom, false, newVNode);\n    }\n  };\n\n  Object.defineProperty(fnMethod, 'wrapped', {\n    configurable: false,\n    enumerable: false,\n    value: true,\n    writable: false\n  });\n  return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n  var previousKey = \"$\" + eventName;\n  var previousArgs = dom[previousKey];\n\n  if (previousArgs) {\n    if (previousArgs[1].wrapped) {\n      return;\n    }\n\n    dom.removeEventListener(previousArgs[0], previousArgs[1]);\n    dom[previousKey] = null;\n  }\n\n  if (isFunction(handler)) {\n    dom.addEventListener(eventName, handler);\n    dom[previousKey] = [eventName, handler];\n  }\n}\n\nfunction isCheckedType(type) {\n  return type === 'checkbox' || type === 'radio';\n}\n\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\n\nfunction emptywrapper(event) {\n  event.stopPropagation();\n}\n\nemptywrapper.wrapped = true;\n\nfunction inputEvents(dom, nextPropsOrEmpty) {\n  if (isCheckedType(nextPropsOrEmpty.type)) {\n    attachEvent(dom, 'change', wrappedOnChange);\n    attachEvent(dom, 'click', emptywrapper);\n  } else {\n    attachEvent(dom, 'input', onTextInputChange);\n  }\n}\n\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n  var type = nextPropsOrEmpty.type;\n  var value = nextPropsOrEmpty.value;\n  var checked = nextPropsOrEmpty.checked;\n  var multiple = nextPropsOrEmpty.multiple;\n  var defaultValue = nextPropsOrEmpty.defaultValue;\n  var hasValue = !isNullOrUndef(value);\n\n  if (type && type !== dom.type) {\n    dom.setAttribute('type', type);\n  }\n\n  if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n    dom.multiple = multiple;\n  }\n\n  if (!isNullOrUndef(defaultValue) && !hasValue) {\n    dom.defaultValue = defaultValue + '';\n  }\n\n  if (isCheckedType(type)) {\n    if (hasValue) {\n      dom.value = value;\n    }\n\n    if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  } else {\n    if (hasValue && dom.value !== value) {\n      dom.defaultValue = value;\n      dom.value = value;\n    } else if (!isNullOrUndef(checked)) {\n      dom.checked = checked;\n    }\n  }\n}\n\nfunction updateChildOptions(vNode, value) {\n  if (vNode.type === 'option') {\n    updateChildOption(vNode, value);\n  } else {\n    var children = vNode.children;\n    var flags = vNode.flags;\n\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      updateChildOptions(children.$LI, value);\n    } else if (flags & 8\n    /* ComponentFunction */\n    ) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags === 2\n    /* HasVNodeChildren */\n    ) {\n      updateChildOptions(children, value);\n    } else if (vNode.childFlags & 12\n    /* MultipleChildren */\n    ) {\n      for (var i = 0, len = children.length; i < len; ++i) {\n        updateChildOptions(children[i], value);\n      }\n    }\n  }\n}\n\nfunction updateChildOption(vNode, value) {\n  var props = vNode.props || EMPTY_OBJ;\n  var dom = vNode.dom; // we do this as multiple may have changed\n\n  dom.value = props.value;\n\n  if (props.value === value || isArray(value) && value.indexOf(props.value) !== -1) {\n    dom.selected = true;\n  } else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n    dom.selected = props.selected || false;\n  }\n}\n\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\n\nfunction selectEvents(dom) {\n  attachEvent(dom, 'change', onSelectChange);\n}\n\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n  var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n\n  if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n    dom.multiple = multiplePropInBoolean;\n  }\n\n  var index = nextPropsOrEmpty.selectedIndex;\n\n  if (index === -1) {\n    dom.selectedIndex = -1;\n  }\n\n  var childFlags = vNode.childFlags;\n\n  if (childFlags !== 1\n  /* HasInvalidChildren */\n  ) {\n    var value = nextPropsOrEmpty.value;\n\n    if (isNumber(index) && index > -1 && dom.options[index]) {\n      value = dom.options[index].value;\n    }\n\n    if (mounting && isNullOrUndef(value)) {\n      value = nextPropsOrEmpty.defaultValue;\n    }\n\n    updateChildOptions(vNode, value);\n  }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\n\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n  attachEvent(dom, 'input', onTextareaInputChange);\n\n  if (nextPropsOrEmpty.onChange) {\n    attachEvent(dom, 'change', wrappedOnChange$1);\n  }\n}\n\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n  var value = nextPropsOrEmpty.value;\n  var domValue = dom.value;\n\n  if (isNullOrUndef(value)) {\n    if (mounting) {\n      var defaultValue = nextPropsOrEmpty.defaultValue;\n\n      if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n        dom.defaultValue = defaultValue;\n        dom.value = defaultValue;\n      }\n    }\n  } else if (domValue !== value) {\n    /* There is value so keep it controlled */\n    dom.defaultValue = value;\n    dom.value = value;\n  }\n}\n\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n  if (flags & 64\n  /* InputElement */\n  ) {\n    applyValueInput(nextPropsOrEmpty, dom);\n  } else if (flags & 256\n  /* SelectElement */\n  ) {\n    applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n  } else if (flags & 128\n  /* TextareaElement */\n  ) {\n    applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n  }\n\n  if (isControlled) {\n    dom.$V = vNode;\n  }\n}\n\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n  if (flags & 64\n  /* InputElement */\n  ) {\n    inputEvents(dom, nextPropsOrEmpty);\n  } else if (flags & 256\n  /* SelectElement */\n  ) {\n    selectEvents(dom);\n  } else if (flags & 128\n  /* TextareaElement */\n  ) {\n    textAreaEvents(dom, nextPropsOrEmpty);\n  }\n}\n\nfunction isControlledFormElement(nextPropsOrEmpty) {\n  return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n  return {\n    current: null\n  };\n}\n\nfunction forwardRef(render) {\n  // @ts-ignore\n  return {\n    render: render\n  };\n}\n\nfunction unmountRef(ref) {\n  if (ref) {\n    if (!safeCall1(ref, null) && ref.current) {\n      ref.current = null;\n    }\n  }\n}\n\nfunction mountRef(ref, value, lifecycle) {\n  if (ref && (isFunction(ref) || ref.current !== void 0)) {\n    lifecycle.push(function () {\n      if (!safeCall1(ref, value) && ref.current !== void 0) {\n        ref.current = value;\n      }\n    });\n  }\n}\n\nfunction remove(vNode, parentDOM) {\n  unmount(vNode);\n  removeVNodeDOM(vNode, parentDOM);\n}\n\nfunction unmount(vNode) {\n  var flags = vNode.flags;\n  var children = vNode.children;\n  var ref;\n\n  if (flags & 481\n  /* Element */\n  ) {\n    ref = vNode.ref;\n    var props = vNode.props;\n    unmountRef(ref);\n    var childFlags = vNode.childFlags;\n\n    if (!isNull(props)) {\n      var keys = Object.keys(props);\n\n      for (var i = 0, len = keys.length; i < len; i++) {\n        var key = keys[i];\n\n        if (syntheticEvents[key]) {\n          unmountSyntheticEvent(key, vNode.dom);\n        }\n      }\n    }\n\n    if (childFlags & 12\n    /* MultipleChildren */\n    ) {\n      unmountAllChildren(children);\n    } else if (childFlags === 2\n    /* HasVNodeChildren */\n    ) {\n      unmount(children);\n    }\n  } else if (children) {\n    if (flags & 4\n    /* ComponentClass */\n    ) {\n      if (isFunction(children.componentWillUnmount)) {\n        children.componentWillUnmount();\n      }\n\n      unmountRef(vNode.ref);\n      children.$UN = true;\n      unmount(children.$LI);\n    } else if (flags & 8\n    /* ComponentFunction */\n    ) {\n      ref = vNode.ref;\n\n      if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n        ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n      }\n\n      unmount(children);\n    } else if (flags & 1024\n    /* Portal */\n    ) {\n      remove(children, vNode.ref);\n    } else if (flags & 8192\n    /* Fragment */\n    ) {\n      if (vNode.childFlags & 12\n      /* MultipleChildren */\n      ) {\n        unmountAllChildren(children);\n      }\n    }\n  }\n}\n\nfunction unmountAllChildren(children) {\n  for (var i = 0, len = children.length; i < len; ++i) {\n    unmount(children[i]);\n  }\n}\n\nfunction clearDOM(dom) {\n  // Optimization for clearing dom\n  dom.textContent = '';\n}\n\nfunction removeAllChildren(dom, vNode, children) {\n  unmountAllChildren(children);\n\n  if (vNode.flags & 8192\n  /* Fragment */\n  ) {\n    removeVNodeDOM(vNode, dom);\n  } else {\n    clearDOM(dom);\n  }\n}\n\nfunction wrapLinkEvent(nextValue) {\n  // This variable makes sure there is no \"this\" context in callback\n  var ev = nextValue.event;\n  return function (e) {\n    ev(nextValue.data, e);\n  };\n}\n\nfunction patchEvent(name, lastValue, nextValue, dom) {\n  if (isLinkEventObject(nextValue)) {\n    if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n      return;\n    }\n\n    nextValue = wrapLinkEvent(nextValue);\n  }\n\n  attachEvent(dom, normalizeEventName(name), nextValue);\n} // We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\n\n\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n  if (isNullOrUndef(nextAttrValue)) {\n    dom.removeAttribute('style');\n    return;\n  }\n\n  var domStyle = dom.style;\n  var style;\n  var value;\n\n  if (isString(nextAttrValue)) {\n    domStyle.cssText = nextAttrValue;\n    return;\n  }\n\n  if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n    for (style in nextAttrValue) {\n      // do not add a hasOwnProperty check here, it affects performance\n      value = nextAttrValue[style];\n\n      if (value !== lastAttrValue[style]) {\n        domStyle.setProperty(style, value);\n      }\n    }\n\n    for (style in lastAttrValue) {\n      if (isNullOrUndef(nextAttrValue[style])) {\n        domStyle.removeProperty(style);\n      }\n    }\n  } else {\n    for (style in nextAttrValue) {\n      value = nextAttrValue[style];\n      domStyle.setProperty(style, value);\n    }\n  }\n}\n\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n  var lastHtml = lastValue && lastValue.__html || '';\n  var nextHtml = nextValue && nextValue.__html || '';\n\n  if (lastHtml !== nextHtml) {\n    if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n      if (!isNull(lastVNode)) {\n        if (lastVNode.childFlags & 12\n        /* MultipleChildren */\n        ) {\n          unmountAllChildren(lastVNode.children);\n        } else if (lastVNode.childFlags === 2\n        /* HasVNodeChildren */\n        ) {\n          unmount(lastVNode.children);\n        }\n\n        lastVNode.children = null;\n        lastVNode.childFlags = 1\n        /* HasInvalidChildren */\n        ;\n      }\n\n      dom.innerHTML = nextHtml;\n    }\n  }\n}\n\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n  switch (prop) {\n    case 'children':\n    case 'childrenType':\n    case 'className':\n    case 'defaultValue':\n    case 'key':\n    case 'multiple':\n    case 'ref':\n    case 'selectedIndex':\n      break;\n\n    case 'autoFocus':\n      dom.autofocus = !!nextValue;\n      break;\n\n    case 'allowfullscreen':\n    case 'autoplay':\n    case 'capture':\n    case 'checked':\n    case 'controls':\n    case 'default':\n    case 'disabled':\n    case 'hidden':\n    case 'indeterminate':\n    case 'loop':\n    case 'muted':\n    case 'novalidate':\n    case 'open':\n    case 'readOnly':\n    case 'required':\n    case 'reversed':\n    case 'scoped':\n    case 'seamless':\n    case 'selected':\n      dom[prop] = !!nextValue;\n      break;\n\n    case 'defaultChecked':\n    case 'value':\n    case 'volume':\n      if (hasControlledValue && prop === 'value') {\n        break;\n      }\n\n      var value = isNullOrUndef(nextValue) ? '' : nextValue;\n\n      if (dom[prop] !== value) {\n        dom[prop] = value;\n      }\n\n      break;\n\n    case 'style':\n      patchStyle(lastValue, nextValue, dom);\n      break;\n\n    case 'dangerouslySetInnerHTML':\n      patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n      break;\n\n    default:\n      if (syntheticEvents[prop]) {\n        handleSyntheticEvent(prop, lastValue, nextValue, dom);\n      } else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n        patchEvent(prop, lastValue, nextValue, dom);\n      } else if (isNullOrUndef(nextValue)) {\n        dom.removeAttribute(prop);\n      } else if (isSVG && namespaces[prop]) {\n        // We optimize for isSVG being false\n        // If we end up in this path we can read property again\n        dom.setAttributeNS(namespaces[prop], prop, nextValue);\n      } else {\n        dom.setAttribute(prop, nextValue);\n      }\n\n      break;\n  }\n}\n\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n  var hasControlledValue = false;\n  var isFormElement = (flags & 448\n  /* FormElement */\n  ) > 0;\n\n  if (isFormElement) {\n    hasControlledValue = isControlledFormElement(props);\n\n    if (hasControlledValue) {\n      addFormElementEventHandlers(flags, dom, props);\n    }\n  }\n\n  for (var prop in props) {\n    // do not add a hasOwnProperty check here, it affects performance\n    patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n  }\n\n  if (isFormElement) {\n    processElement(flags, vNode, dom, props, true, hasControlledValue);\n  }\n}\n\nfunction renderNewInput(instance, props, context) {\n  var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n  var childContext = context;\n\n  if (isFunction(instance.getChildContext)) {\n    childContext = combineFrom(context, instance.getChildContext());\n  }\n\n  instance.$CX = childContext;\n  return nextInput;\n}\n\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n  var instance = new Component(props, context);\n  var usesNewAPI = instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate);\n  instance.$SVG = isSVG;\n  instance.$L = lifecycle;\n  vNode.children = instance;\n  instance.$BS = false;\n  instance.context = context;\n\n  if (instance.props === EMPTY_OBJ) {\n    instance.props = props;\n  }\n\n  if (!usesNewAPI) {\n    if (isFunction(instance.componentWillMount)) {\n      instance.$BR = true;\n      instance.componentWillMount();\n      var pending = instance.$PS;\n\n      if (!isNull(pending)) {\n        var state = instance.state;\n\n        if (isNull(state)) {\n          instance.state = pending;\n        } else {\n          for (var key in pending) {\n            state[key] = pending[key];\n          }\n        }\n\n        instance.$PS = null;\n      }\n\n      instance.$BR = false;\n    }\n  } else {\n    instance.state = createDerivedState(instance, props, instance.state);\n  }\n\n  instance.$LI = renderNewInput(instance, props, context);\n  return instance;\n}\n\nfunction renderFunctionalComponent(vNode, context) {\n  var props = vNode.props || EMPTY_OBJ;\n  return vNode.flags & 32768\n  /* ForwardRef */\n  ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var flags = vNode.flags |= 16384\n  /* InUse */\n  ;\n\n  if (flags & 481\n  /* Element */\n  ) {\n    mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (flags & 4\n  /* ComponentClass */\n  ) {\n    mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (flags & 8\n  /* ComponentFunction */\n  ) {\n    mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    mountFunctionalComponentCallbacks(vNode, lifecycle);\n  } else if (flags & 512\n  /* Void */\n  || flags & 16\n  /* Text */\n  ) {\n    mountText(vNode, parentDOM, nextNode);\n  } else if (flags & 8192\n  /* Fragment */\n  ) {\n    mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n  } else if (flags & 1024\n  /* Portal */\n  ) {\n    mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n  } else ;\n}\n\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n  mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n  var placeHolderVNode = createVoidVNode();\n  mountText(placeHolderVNode, parentDOM, nextNode);\n  vNode.dom = placeHolderVNode.dom;\n}\n\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n  var children = vNode.children;\n  var childFlags = vNode.childFlags; // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n\n  if (childFlags & 12\n  /* MultipleChildren */\n  && children.length === 0) {\n    childFlags = vNode.childFlags = 2\n    /* HasVNodeChildren */\n    ;\n    children = vNode.children = createVoidVNode();\n  }\n\n  if (childFlags === 2\n  /* HasVNodeChildren */\n  ) {\n    mount(children, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else {\n    mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n  }\n}\n\nfunction mountText(vNode, parentDOM, nextNode) {\n  var dom = vNode.dom = document.createTextNode(vNode.children);\n\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n}\n\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var flags = vNode.flags;\n  var props = vNode.props;\n  var className = vNode.className;\n  var childFlags = vNode.childFlags;\n  var dom = vNode.dom = documentCreateElement(vNode.type, isSVG = isSVG || (flags & 32\n  /* SvgElement */\n  ) > 0);\n  var children = vNode.children;\n\n  if (!isNullOrUndef(className) && className !== '') {\n    if (isSVG) {\n      dom.setAttribute('class', className);\n    } else {\n      dom.className = className;\n    }\n  }\n\n  if (childFlags === 16\n  /* HasTextChildren */\n  ) {\n    setTextContent(dom, children);\n  } else if (childFlags !== 1\n  /* HasInvalidChildren */\n  ) {\n    var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n\n    if (childFlags === 2\n    /* HasVNodeChildren */\n    ) {\n      if (children.flags & 16384\n      /* InUse */\n      ) {\n        vNode.children = children = directClone(children);\n      }\n\n      mount(children, dom, context, childrenIsSVG, null, lifecycle);\n    } else if (childFlags === 8\n    /* HasKeyedChildren */\n    || childFlags === 4\n    /* HasNonKeyedChildren */\n    ) {\n      mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n    }\n  }\n\n  if (!isNull(parentDOM)) {\n    insertOrAppend(parentDOM, dom, nextNode);\n  }\n\n  if (!isNull(props)) {\n    mountProps(vNode, flags, props, dom, isSVG);\n  }\n\n  mountRef(vNode.ref, dom, lifecycle);\n}\n\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n  for (var i = 0; i < children.length; ++i) {\n    var child = children[i];\n\n    if (child.flags & 16384\n    /* InUse */\n    ) {\n      children[i] = child = directClone(child);\n    }\n\n    mount(child, dom, context, isSVG, nextNode, lifecycle);\n  }\n}\n\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n  mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n  mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\n\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  mount(vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context)), parentDOM, context, isSVG, nextNode, lifecycle);\n}\n\nfunction createClassMountCallback(instance) {\n  return function () {\n    instance.componentDidMount();\n  };\n}\n\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n  mountRef(ref, instance, lifecycle);\n\n  if (isFunction(instance.componentDidMount)) {\n    lifecycle.push(createClassMountCallback(instance));\n  }\n}\n\nfunction createOnMountCallback(ref, vNode) {\n  return function () {\n    ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n  };\n}\n\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n  var ref = vNode.ref;\n\n  if (!isNullOrUndef(ref)) {\n    safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n\n    if (isFunction(ref.onComponentDidMount)) {\n      lifecycle.push(createOnMountCallback(ref, vNode));\n    }\n  }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n  unmount(lastVNode);\n\n  if ((nextVNode.flags & lastVNode.flags & 2033\n  /* DOMRef */\n  ) !== 0) {\n    mount(nextVNode, null, context, isSVG, null, lifecycle); // Single DOM operation, when we have dom references available\n\n    replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n  } else {\n    mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n    removeVNodeDOM(lastVNode, parentDOM);\n  }\n}\n\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var nextFlags = nextVNode.flags |= 16384\n  /* InUse */\n  ;\n\n  if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048\n  /* ReCreate */\n  ) {\n    if (lastVNode.flags & 16384\n    /* InUse */\n    ) {\n      replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    } else {\n      // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n      mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n  } else if (nextFlags & 481\n  /* Element */\n  ) {\n    patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n  } else if (nextFlags & 4\n  /* ComponentClass */\n  ) {\n    patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (nextFlags & 8\n  /* ComponentFunction */\n  ) {\n    patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n  } else if (nextFlags & 16\n  /* Text */\n  ) {\n    patchText(lastVNode, nextVNode);\n  } else if (nextFlags & 512\n  /* Void */\n  ) {\n    nextVNode.dom = lastVNode.dom;\n  } else if (nextFlags & 8192\n  /* Fragment */\n  ) {\n    patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n  } else {\n    patchPortal(lastVNode, nextVNode, context, lifecycle);\n  }\n}\n\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n  if (lastChildren !== nextChildren) {\n    if (lastChildren !== '') {\n      parentDOM.firstChild.nodeValue = nextChildren;\n    } else {\n      setTextContent(parentDOM, nextChildren);\n    }\n  }\n}\n\nfunction patchContentEditableChildren(dom, nextChildren) {\n  if (dom.textContent !== nextChildren) {\n    dom.textContent = nextChildren;\n  }\n}\n\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n  var lastChildren = lastVNode.children;\n  var nextChildren = nextVNode.children;\n  var lastChildFlags = lastVNode.childFlags;\n  var nextChildFlags = nextVNode.childFlags;\n  var nextNode = null; // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n  // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n\n  if (nextChildFlags & 12\n  /* MultipleChildren */\n  && nextChildren.length === 0) {\n    nextChildFlags = nextVNode.childFlags = 2\n    /* HasVNodeChildren */\n    ;\n    nextChildren = nextVNode.children = createVoidVNode();\n  }\n\n  var nextIsSingle = (nextChildFlags & 2\n  /* HasVNodeChildren */\n  ) !== 0;\n\n  if (lastChildFlags & 12\n  /* MultipleChildren */\n  ) {\n    var lastLen = lastChildren.length; // We need to know Fragment's edge node when\n\n    if ( // It uses keyed algorithm\n    lastChildFlags & 8\n    /* HasKeyedChildren */\n    && nextChildFlags & 8\n    /* HasKeyedChildren */\n    || // It transforms from many to single\n    nextIsSingle || // It will append more nodes\n    !nextIsSingle && nextChildren.length > lastLen) {\n      // When fragment has multiple children there is always at least one vNode\n      nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n    }\n  }\n\n  patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\n\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n  var lastContainer = lastVNode.ref;\n  var nextContainer = nextVNode.ref;\n  var nextChildren = nextVNode.children;\n  patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n  nextVNode.dom = lastVNode.dom;\n\n  if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n    var node = nextChildren.dom;\n    removeChild(lastContainer, node);\n    appendChild(nextContainer, node);\n  }\n}\n\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n  var dom = nextVNode.dom = lastVNode.dom;\n  var lastProps = lastVNode.props;\n  var nextProps = nextVNode.props;\n  var isFormElement = false;\n  var hasControlledValue = false;\n  var nextPropsOrEmpty;\n  isSVG = isSVG || (nextFlags & 32\n  /* SvgElement */\n  ) > 0; // inlined patchProps  -- starts --\n\n  if (lastProps !== nextProps) {\n    var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n    nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n\n    if (nextPropsOrEmpty !== EMPTY_OBJ) {\n      isFormElement = (nextFlags & 448\n      /* FormElement */\n      ) > 0;\n\n      if (isFormElement) {\n        hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n      }\n\n      for (var prop in nextPropsOrEmpty) {\n        var lastValue = lastPropsOrEmpty[prop];\n        var nextValue = nextPropsOrEmpty[prop];\n\n        if (lastValue !== nextValue) {\n          patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n        }\n      }\n    }\n\n    if (lastPropsOrEmpty !== EMPTY_OBJ) {\n      for (var prop$1 in lastPropsOrEmpty) {\n        if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n          patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n        }\n      }\n    }\n  }\n\n  var nextChildren = nextVNode.children;\n  var nextClassName = nextVNode.className; // inlined patchProps  -- ends --\n\n  if (lastVNode.className !== nextClassName) {\n    if (isNullOrUndef(nextClassName)) {\n      dom.removeAttribute('class');\n    } else if (isSVG) {\n      dom.setAttribute('class', nextClassName);\n    } else {\n      dom.className = nextClassName;\n    }\n  }\n\n  if (nextFlags & 4096\n  /* ContentEditable */\n  ) {\n    patchContentEditableChildren(dom, nextChildren);\n  } else {\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n  }\n\n  if (isFormElement) {\n    processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n  }\n\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, dom, lifecycle);\n  }\n}\n\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n  unmount(lastChildren);\n  mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n  removeVNodeDOM(lastChildren, parentDOM);\n}\n\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n  switch (lastChildFlags) {\n    case 2\n    /* HasVNodeChildren */\n    :\n      switch (nextChildFlags) {\n        case 2\n        /* HasVNodeChildren */\n        :\n          patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          remove(lastChildren, parentDOM);\n          break;\n\n        case 16\n        /* HasTextChildren */\n        :\n          unmount(lastChildren);\n          setTextContent(parentDOM, nextChildren);\n          break;\n\n        default:\n          replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n          break;\n      }\n\n      break;\n\n    case 1\n    /* HasInvalidChildren */\n    :\n      switch (nextChildFlags) {\n        case 2\n        /* HasVNodeChildren */\n        :\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          break;\n\n        case 16\n        /* HasTextChildren */\n        :\n          setTextContent(parentDOM, nextChildren);\n          break;\n\n        default:\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n      }\n\n      break;\n\n    case 16\n    /* HasTextChildren */\n    :\n      switch (nextChildFlags) {\n        case 16\n        /* HasTextChildren */\n        :\n          patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n          break;\n\n        case 2\n        /* HasVNodeChildren */\n        :\n          clearDOM(parentDOM);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          clearDOM(parentDOM);\n          break;\n\n        default:\n          clearDOM(parentDOM);\n          mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n      }\n\n      break;\n\n    default:\n      switch (nextChildFlags) {\n        case 16\n        /* HasTextChildren */\n        :\n          unmountAllChildren(lastChildren);\n          setTextContent(parentDOM, nextChildren);\n          break;\n\n        case 2\n        /* HasVNodeChildren */\n        :\n          removeAllChildren(parentDOM, parentVNode, lastChildren);\n          mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n          break;\n\n        case 1\n        /* HasInvalidChildren */\n        :\n          removeAllChildren(parentDOM, parentVNode, lastChildren);\n          break;\n\n        default:\n          var lastLength = lastChildren.length | 0;\n          var nextLength = nextChildren.length | 0; // Fast path's for both algorithms\n\n          if (lastLength === 0) {\n            if (nextLength > 0) {\n              mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n            }\n          } else if (nextLength === 0) {\n            removeAllChildren(parentDOM, parentVNode, lastChildren);\n          } else if (nextChildFlags === 8\n          /* HasKeyedChildren */\n          && lastChildFlags === 8\n          /* HasKeyedChildren */\n          ) {\n            patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n          } else {\n            patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n          }\n\n          break;\n      }\n\n      break;\n  }\n}\n\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n  lifecycle.push(function () {\n    instance.componentDidUpdate(lastProps, lastState, snapshot);\n  });\n}\n\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n  var lastState = instance.state;\n  var lastProps = instance.props;\n  var usesNewAPI = Boolean(instance.$N);\n  var hasSCU = isFunction(instance.shouldComponentUpdate);\n\n  if (usesNewAPI) {\n    nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n  }\n\n  if (force || !hasSCU || hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context)) {\n    if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n      instance.componentWillUpdate(nextProps, nextState, context);\n    }\n\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n    var snapshot = null;\n    var nextInput = renderNewInput(instance, nextProps, context);\n\n    if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n      snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n    }\n\n    patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle); // Dont update Last input, until patch has been succesfully executed\n\n    instance.$LI = nextInput;\n\n    if (isFunction(instance.componentDidUpdate)) {\n      createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n    }\n  } else {\n    instance.props = nextProps;\n    instance.state = nextState;\n    instance.context = context;\n  }\n}\n\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var instance = nextVNode.children = lastVNode.children; // If Component has crashed, ignore it to stay functional\n\n  if (isNull(instance)) {\n    return;\n  }\n\n  instance.$L = lifecycle;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastRef = lastVNode.ref;\n  var nextState = instance.state;\n\n  if (!instance.$N) {\n    if (isFunction(instance.componentWillReceiveProps)) {\n      instance.$BR = true;\n      instance.componentWillReceiveProps(nextProps, context); // If instance component was removed during its own update do nothing.\n\n      if (instance.$UN) {\n        return;\n      }\n\n      instance.$BR = false;\n    }\n\n    if (!isNull(instance.$PS)) {\n      nextState = combineFrom(nextState, instance.$PS);\n      instance.$PS = null;\n    }\n  }\n\n  updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n\n  if (lastRef !== nextRef) {\n    unmountRef(lastRef);\n    mountRef(nextRef, instance, lifecycle);\n  }\n}\n\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n  var shouldUpdate = true;\n  var nextProps = nextVNode.props || EMPTY_OBJ;\n  var nextRef = nextVNode.ref;\n  var lastProps = lastVNode.props;\n  var nextHooksDefined = !isNullOrUndef(nextRef);\n  var lastInput = lastVNode.children;\n\n  if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n    shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n  }\n\n  if (shouldUpdate !== false) {\n    if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n      nextRef.onComponentWillUpdate(lastProps, nextProps);\n    }\n\n    var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n    patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n    nextVNode.children = nextInput;\n\n    if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n      nextRef.onComponentDidUpdate(lastProps, nextProps);\n    }\n  } else {\n    nextVNode.children = lastInput;\n  }\n}\n\nfunction patchText(lastVNode, nextVNode) {\n  var nextText = nextVNode.children;\n  var dom = nextVNode.dom = lastVNode.dom;\n\n  if (nextText !== lastVNode.children) {\n    dom.nodeValue = nextText;\n  }\n}\n\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n  var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n  var i = 0;\n  var nextChild;\n  var lastChild;\n\n  for (; i < commonLength; ++i) {\n    nextChild = nextChildren[i];\n    lastChild = lastChildren[i];\n\n    if (nextChild.flags & 16384\n    /* InUse */\n    ) {\n      nextChild = nextChildren[i] = directClone(nextChild);\n    }\n\n    patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n    lastChildren[i] = nextChild;\n  }\n\n  if (lastChildrenLength < nextChildrenLength) {\n    for (i = commonLength; i < nextChildrenLength; ++i) {\n      nextChild = nextChildren[i];\n\n      if (nextChild.flags & 16384\n      /* InUse */\n      ) {\n        nextChild = nextChildren[i] = directClone(nextChild);\n      }\n\n      mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n    }\n  } else if (lastChildrenLength > nextChildrenLength) {\n    for (i = commonLength; i < lastChildrenLength; ++i) {\n      remove(lastChildren[i], dom);\n    }\n  }\n}\n\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n  var aEnd = aLength - 1;\n  var bEnd = bLength - 1;\n  var j = 0;\n  var aNode = a[j];\n  var bNode = b[j];\n  var nextPos;\n  var nextNode; // Step 1\n  // tslint:disable-next-line\n\n  outer: {\n    // Sync nodes with the same key at the beginning.\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384\n      /* InUse */\n      ) {\n        b[j] = bNode = directClone(bNode);\n      }\n\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n      a[j] = bNode;\n      ++j;\n\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n\n      aNode = a[j];\n      bNode = b[j];\n    }\n\n    aNode = a[aEnd];\n    bNode = b[bEnd]; // Sync nodes with the same key at the end.\n\n    while (aNode.key === bNode.key) {\n      if (bNode.flags & 16384\n      /* InUse */\n      ) {\n        b[bEnd] = bNode = directClone(bNode);\n      }\n\n      patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n      a[aEnd] = bNode;\n      aEnd--;\n      bEnd--;\n\n      if (j > aEnd || j > bEnd) {\n        break outer;\n      }\n\n      aNode = a[aEnd];\n      bNode = b[bEnd];\n    }\n  }\n\n  if (j > aEnd) {\n    if (j <= bEnd) {\n      nextPos = bEnd + 1;\n      nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n\n      while (j <= bEnd) {\n        bNode = b[j];\n\n        if (bNode.flags & 16384\n        /* InUse */\n        ) {\n          b[j] = bNode = directClone(bNode);\n        }\n\n        ++j;\n        mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n      }\n    }\n  } else if (j > bEnd) {\n    while (j <= aEnd) {\n      remove(a[j++], dom);\n    }\n  } else {\n    patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n  }\n}\n\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n  var aNode;\n  var bNode;\n  var nextPos;\n  var i = 0;\n  var aStart = j;\n  var bStart = j;\n  var aLeft = aEnd - j + 1;\n  var bLeft = bEnd - j + 1;\n  var sources = new Int32Array(bLeft + 1); // Keep track if its possible to remove whole DOM using textContent = '';\n\n  var canRemoveWholeContent = aLeft === aLength;\n  var moved = false;\n  var pos = 0;\n  var patched = 0; // When sizes are small, just loop them through\n\n  if (bLength < 4 || (aLeft | bLeft) < 32) {\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n\n      if (patched < bLeft) {\n        for (j = bStart; j <= bEnd; j++) {\n          bNode = b[j];\n\n          if (aNode.key === bNode.key) {\n            sources[j - bStart] = i + 1;\n\n            if (canRemoveWholeContent) {\n              canRemoveWholeContent = false;\n\n              while (aStart < i) {\n                remove(a[aStart++], dom);\n              }\n            }\n\n            if (pos > j) {\n              moved = true;\n            } else {\n              pos = j;\n            }\n\n            if (bNode.flags & 16384\n            /* InUse */\n            ) {\n              b[j] = bNode = directClone(bNode);\n            }\n\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            ++patched;\n            break;\n          }\n        }\n\n        if (!canRemoveWholeContent && j > bEnd) {\n          remove(aNode, dom);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom);\n      }\n    }\n  } else {\n    var keyIndex = {}; // Map keys by their index\n\n    for (i = bStart; i <= bEnd; ++i) {\n      keyIndex[b[i].key] = i;\n    } // Try to patch same keys\n\n\n    for (i = aStart; i <= aEnd; ++i) {\n      aNode = a[i];\n\n      if (patched < bLeft) {\n        j = keyIndex[aNode.key];\n\n        if (j !== void 0) {\n          if (canRemoveWholeContent) {\n            canRemoveWholeContent = false;\n\n            while (i > aStart) {\n              remove(a[aStart++], dom);\n            }\n          }\n\n          sources[j - bStart] = i + 1;\n\n          if (pos > j) {\n            moved = true;\n          } else {\n            pos = j;\n          }\n\n          bNode = b[j];\n\n          if (bNode.flags & 16384\n          /* InUse */\n          ) {\n            b[j] = bNode = directClone(bNode);\n          }\n\n          patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n          ++patched;\n        } else if (!canRemoveWholeContent) {\n          remove(aNode, dom);\n        }\n      } else if (!canRemoveWholeContent) {\n        remove(aNode, dom);\n      }\n    }\n  } // fast-path: if nothing patched remove all old and add all new\n\n\n  if (canRemoveWholeContent) {\n    removeAllChildren(dom, parentVNode, a);\n    mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n  } else if (moved) {\n    var seq = lis_algorithm(sources);\n    j = seq.length - 1;\n\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n\n        if (bNode.flags & 16384\n        /* InUse */\n        ) {\n          b[pos] = bNode = directClone(bNode);\n        }\n\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n      } else if (j < 0 || i !== seq[j]) {\n        pos = i + bStart;\n        bNode = b[pos];\n        nextPos = pos + 1;\n        moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n      } else {\n        j--;\n      }\n    }\n  } else if (patched !== bLeft) {\n    // when patched count doesn't match b length we need to insert those new ones\n    // loop backwards so we can use insertBefore\n    for (i = bLeft - 1; i >= 0; i--) {\n      if (sources[i] === 0) {\n        pos = i + bStart;\n        bNode = b[pos];\n\n        if (bNode.flags & 16384\n        /* InUse */\n        ) {\n          b[pos] = bNode = directClone(bNode);\n        }\n\n        nextPos = pos + 1;\n        mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n      }\n    }\n  }\n}\n\nvar result;\nvar p;\nvar maxLen = 0; // https://en.wikipedia.org/wiki/Longest_increasing_subsequence\n\nfunction lis_algorithm(arr) {\n  var arrI = 0;\n  var i = 0;\n  var j = 0;\n  var k = 0;\n  var u = 0;\n  var v = 0;\n  var c = 0;\n  var len = arr.length;\n\n  if (len > maxLen) {\n    maxLen = len;\n    result = new Int32Array(len);\n    p = new Int32Array(len);\n  }\n\n  for (; i < len; ++i) {\n    arrI = arr[i];\n\n    if (arrI !== 0) {\n      j = result[k];\n\n      if (arr[j] < arrI) {\n        p[i] = j;\n        result[++k] = i;\n        continue;\n      }\n\n      u = 0;\n      v = k;\n\n      while (u < v) {\n        c = u + v >> 1;\n\n        if (arr[result[c]] < arrI) {\n          u = c + 1;\n        } else {\n          v = c;\n        }\n      }\n\n      if (arrI < arr[result[u]]) {\n        if (u > 0) {\n          p[i] = result[u - 1];\n        }\n\n        result[u] = i;\n      }\n    }\n  }\n\n  u = k + 1;\n  var seq = new Int32Array(u);\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    seq[u] = v;\n    v = p[v];\n    result[u] = 0;\n  }\n\n  return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\n\nif (hasDocumentAvailable) {\n  /*\n   * Defining $EV and $V properties on Node.prototype\n   * fixes v8 \"wrong map\" de-optimization\n   */\n  if (window.Node) {\n    Node.prototype.$EV = null;\n    Node.prototype.$V = null;\n  }\n}\n\nfunction __render(input, parentDOM, callback, context) {\n  var lifecycle = [];\n  var rootInput = parentDOM.$V;\n  renderCheck.v = true;\n\n  if (isNullOrUndef(rootInput)) {\n    if (!isNullOrUndef(input)) {\n      if (input.flags & 16384\n      /* InUse */\n      ) {\n        input = directClone(input);\n      }\n\n      mount(input, parentDOM, context, false, null, lifecycle);\n      parentDOM.$V = input;\n      rootInput = input;\n    }\n  } else {\n    if (isNullOrUndef(input)) {\n      remove(rootInput, parentDOM);\n      parentDOM.$V = null;\n    } else {\n      if (input.flags & 16384\n      /* InUse */\n      ) {\n        input = directClone(input);\n      }\n\n      patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n      rootInput = parentDOM.$V = input;\n    }\n  }\n\n  callAll(lifecycle);\n  renderCheck.v = false;\n\n  if (isFunction(callback)) {\n    callback();\n  }\n\n  if (isFunction(options.renderComplete)) {\n    options.renderComplete(rootInput, parentDOM);\n  }\n}\n\nfunction render(input, parentDOM, callback, context) {\n  if (callback === void 0) callback = null;\n  if (context === void 0) context = EMPTY_OBJ;\n\n  __render(input, parentDOM, callback, context);\n}\n\nfunction createRenderer(parentDOM) {\n  return function renderer(lastInput, nextInput, callback, context) {\n    if (!parentDOM) {\n      parentDOM = lastInput;\n    }\n\n    render(nextInput, parentDOM, callback, context);\n  };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined' ? Promise.resolve().then.bind(Promise.resolve()) : function (a) {\n  window.setTimeout(a, 0);\n};\nvar microTaskPending = false;\n\nfunction queueStateChanges(component, newState, callback, force) {\n  var pending = component.$PS;\n\n  if (isFunction(newState)) {\n    newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n  }\n\n  if (isNullOrUndef(pending)) {\n    component.$PS = newState;\n  } else {\n    for (var stateKey in newState) {\n      pending[stateKey] = newState[stateKey];\n    }\n  }\n\n  if (!component.$BR) {\n    if (!renderCheck.v) {\n      if (QUEUE.length === 0) {\n        applyState(component, force);\n\n        if (isFunction(callback)) {\n          callback.call(component);\n        }\n\n        return;\n      }\n    }\n\n    if (QUEUE.indexOf(component) === -1) {\n      QUEUE.push(component);\n    }\n\n    if (force) {\n      component.$F = true;\n    }\n\n    if (!microTaskPending) {\n      microTaskPending = true;\n      nextTick(rerender);\n    }\n\n    if (isFunction(callback)) {\n      var QU = component.$QU;\n\n      if (!QU) {\n        QU = component.$QU = [];\n      }\n\n      QU.push(callback);\n    }\n  } else if (isFunction(callback)) {\n    component.$L.push(callback.bind(component));\n  }\n}\n\nfunction callSetStateCallbacks(component) {\n  var queue = component.$QU;\n\n  for (var i = 0; i < queue.length; ++i) {\n    queue[i].call(component);\n  }\n\n  component.$QU = null;\n}\n\nfunction rerender() {\n  var component;\n  microTaskPending = false;\n\n  while (component = QUEUE.shift()) {\n    if (!component.$UN) {\n      var force = component.$F;\n      component.$F = false;\n      applyState(component, force);\n\n      if (component.$QU) {\n        callSetStateCallbacks(component);\n      }\n    }\n  }\n}\n\nfunction applyState(component, force) {\n  if (force || !component.$BR) {\n    var pendingState = component.$PS;\n    component.$PS = null;\n    var lifecycle = [];\n    renderCheck.v = true;\n    updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n    callAll(lifecycle);\n    renderCheck.v = false;\n  } else {\n    component.state = component.$PS;\n    component.$PS = null;\n  }\n}\n\nvar Component = function Component(props, context) {\n  // Public\n  this.state = null; // Internal properties\n\n  this.$BR = false; // BLOCK RENDER\n\n  this.$BS = true; // BLOCK STATE\n\n  this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n\n  this.$LI = null; // LAST INPUT\n\n  this.$UN = false; // UNMOUNTED\n\n  this.$CX = null; // CHILDCONTEXT\n\n  this.$QU = null; // QUEUE\n\n  this.$N = false; // Uses new lifecycle API Flag\n\n  this.$L = null; // Current lifecycle of this component\n\n  this.$SVG = false; // Flag to keep track if component is inside SVG tree\n\n  this.$F = false; // Force update flag\n\n  this.props = props || EMPTY_OBJ;\n  this.context = context || EMPTY_OBJ; // context should not be mutable\n};\n\nComponent.prototype.forceUpdate = function forceUpdate(callback) {\n  if (this.$UN) {\n    return;\n  } // Do not allow double render during force update\n\n\n  queueStateChanges(this, {}, callback, true);\n};\n\nComponent.prototype.setState = function setState(newState, callback) {\n  if (this.$UN) {\n    return;\n  }\n\n  if (!this.$BS) {\n    queueStateChanges(this, newState, callback, false);\n  }\n};\n\nComponent.prototype.render = function render(_nextProps, _nextState, _nextContext) {\n  return null;\n};\n\nvar version = \"7.4.11\";\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };","map":{"version":3,"sources":["C:/Users/ciara/OneDrive - GMIT/Coin A-Z Test Repo/frontend/node_modules/inferno/dist/index.esm.js"],"names":["isArray","Array","isStringOrNumber","o","type","isNullOrUndef","isInvalid","isFunction","isString","isNumber","isNull","isUndefined","combineFrom","first","second","out","key","key$1","linkEvent","data","event","isLinkEventObject","EMPTY_OBJ","Fragment","normalizeEventName","name","substr","toLowerCase","appendChild","parentDOM","dom","insertOrAppend","newNode","nextNode","insertBefore","documentCreateElement","tag","isSVG","document","createElementNS","createElement","replaceChild","newDom","lastDom","removeChild","childNode","callAll","arrayFn","i","length","findChildVNode","vNode","startEdge","flags","children","$LI","childFlags","findDOMfromVNode","removeVNodeDOM","len","moveVNodeDOM","createDerivedState","instance","nextProps","state","constructor","getDerivedStateFromProps","renderCheck","v","options","componentComparator","createVNode","renderComplete","setTextContent","textContent","isLastValueSameLinkEvent","lastValue","nextValue","mergeUnsetProperties","to","from","propName","safeCall1","method","arg1","keyPrefix","V","className","props","ref","childFlag","normalizeChildren","mergeDefaultHooks","defaultHooks","render","mergeDefaultProps","defaultProps","resolveComponentFlags","prototype","createComponentVNode","createTextVNode","text","createFragment","fragment","createVoidVNode","normalizeProps","undefined","cloneFragment","vNodeToClone","oldChildren","directClone","map","propsToClone","createPortal","container","normalizedRoot","normalizeRoot","_normalizeVNodes","nodes","result","index","currentKey","n","newKey","oldKey","isPrefixedKey","substring","push","getFlagsForElementVnode","newChildren","newChildFlags","slice","needsCloning","isNullKey","isPrefixed","input","xlinkNS","xmlNS","namespaces","getDelegatedEventObject","onClick","onDblClick","onFocusIn","onFocusOut","onKeyDown","onKeyPress","onKeyUp","onMouseDown","onMouseMove","onMouseUp","onTouchEnd","onTouchMove","onTouchStart","attachedEventCounts","attachedEvents","syntheticEvents","updateOrAddSyntheticEvent","eventsObject","$EV","attachEventToDocument","unmountSyntheticEvent","removeEventListener","handleSyntheticEvent","lastEvent","nextEvent","getTargetNode","composedPath","target","dispatchEvents","isClick","eventData","disabled","currentEvent","cancelBubble","parentNode","stopPropagation","immediatePropagationStopped","stopImmediatePropagation","isDefaultPrevented","defaultPrevented","isPropagationStopped","extendEventProperties","Object","defineProperty","configurable","get","rootClickEvent","button","rootEvent","attachedEvent","addEventListener","isSameInnerHTML","innerHTML","tempdom","triggerEventListener","methodName","e","listener","nativeListenerName","createWrappedFunction","applyValue","fnMethod","$V","newVNode","newProps","enumerable","value","writable","attachEvent","eventName","handler","previousKey","previousArgs","wrapped","isCheckedType","onTextInputChange","applyValueInput","wrappedOnChange","emptywrapper","inputEvents","nextPropsOrEmpty","checked","multiple","defaultValue","hasValue","setAttribute","updateChildOptions","updateChildOption","indexOf","selected","onSelectChange","applyValueSelect","selectEvents","mounting","multiplePropInBoolean","Boolean","selectedIndex","onTextareaInputChange","applyValueTextArea","wrappedOnChange$1","textAreaEvents","onChange","domValue","processElement","isControlled","addFormElementEventHandlers","isControlledFormElement","createRef","current","forwardRef","unmountRef","mountRef","lifecycle","remove","unmount","keys","unmountAllChildren","componentWillUnmount","$UN","onComponentWillUnmount","clearDOM","removeAllChildren","wrapLinkEvent","ev","patchEvent","patchStyle","lastAttrValue","nextAttrValue","removeAttribute","domStyle","style","cssText","setProperty","removeProperty","patchDangerInnerHTML","lastVNode","lastHtml","__html","nextHtml","patchProp","prop","hasControlledValue","autofocus","charCodeAt","setAttributeNS","mountProps","isFormElement","renderNewInput","context","nextInput","childContext","getChildContext","$CX","createClassComponentInstance","Component","usesNewAPI","$N","getSnapshotBeforeUpdate","$SVG","$L","$BS","componentWillMount","$BR","pending","$PS","renderFunctionalComponent","mount","mountElement","mountClassComponent","mountFunctionalComponent","mountFunctionalComponentCallbacks","mountText","mountFragment","mountPortal","placeHolderVNode","mountArrayChildren","createTextNode","childrenIsSVG","child","mountClassComponentCallbacks","createClassMountCallback","componentDidMount","createOnMountCallback","onComponentDidMount","onComponentWillMount","replaceWithNewNode","nextVNode","patch","nextFlags","patchElement","patchClassComponent","patchFunctionalComponent","patchText","patchFragment","patchPortal","patchSingleTextChild","lastChildren","nextChildren","firstChild","nodeValue","patchContentEditableChildren","lastChildFlags","nextChildFlags","nextIsSingle","lastLen","nextSibling","patchChildren","lastContainer","nextContainer","node","lastProps","lastPropsOrEmpty","prop$1","nextClassName","nextRef","lastRef","replaceOneVNodeWithMultipleVNodes","parentVNode","lastLength","nextLength","patchKeyedChildren","patchNonKeyedChildren","createDidUpdate","lastState","snapshot","componentDidUpdate","updateClassComponent","nextState","force","hasSCU","shouldComponentUpdate","componentWillUpdate","componentWillReceiveProps","shouldUpdate","nextHooksDefined","lastInput","onComponentShouldUpdate","onComponentWillUpdate","onComponentDidUpdate","nextText","lastChildrenLength","nextChildrenLength","commonLength","nextChild","lastChild","a","b","aLength","bLength","outerEdge","aEnd","bEnd","j","aNode","bNode","nextPos","outer","patchKeyedChildrenComplex","aStart","bStart","aLeft","bLeft","sources","Int32Array","canRemoveWholeContent","moved","pos","patched","keyIndex","seq","lis_algorithm","p","maxLen","arr","arrI","k","u","c","hasDocumentAvailable","window","Node","__render","callback","rootInput","createRenderer","renderer","QUEUE","nextTick","Promise","resolve","then","bind","setTimeout","microTaskPending","queueStateChanges","component","newState","stateKey","applyState","call","$F","rerender","QU","$QU","callSetStateCallbacks","queue","shift","pendingState","forceUpdate","setState","_nextProps","_nextState","_nextContext","version","_CI","_HI","_M","_MCCC","_ME","_MFCC","_MP","_MR","_RFC"],"mappings":"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","sourcesContent":["var isArray = Array.isArray;\nfunction isStringOrNumber(o) {\n    var type = typeof o;\n    return type === 'string' || type === 'number';\n}\nfunction isNullOrUndef(o) {\n    return o === void 0 || o === null;\n}\nfunction isInvalid(o) {\n    return o === null || o === false || o === true || o === void 0;\n}\nfunction isFunction(o) {\n    return typeof o === 'function';\n}\nfunction isString(o) {\n    return typeof o === 'string';\n}\nfunction isNumber(o) {\n    return typeof o === 'number';\n}\nfunction isNull(o) {\n    return o === null;\n}\nfunction isUndefined(o) {\n    return o === void 0;\n}\nfunction combineFrom(first, second) {\n    var out = {};\n    if (first) {\n        for (var key in first) {\n            out[key] = first[key];\n        }\n    }\n    if (second) {\n        for (var key$1 in second) {\n            out[key$1] = second[key$1];\n        }\n    }\n    return out;\n}\n\n/**\n * Links given data to event as first parameter\n * @param {*} data data to be linked, it will be available in function as first parameter\n * @param {Function} event Function to be called when event occurs\n * @returns {{data: *, event: Function}}\n */\nfunction linkEvent(data, event) {\n    if (isFunction(event)) {\n        return { data: data, event: event };\n    }\n    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers\n}\n// object.event should always be function, otherwise its badly created object.\nfunction isLinkEventObject(o) {\n    return !isNull(o) && typeof o === 'object';\n}\n\n// We need EMPTY_OBJ defined in one place.\n// Its used for comparison so we cant inline it into shared\nvar EMPTY_OBJ = {};\nvar Fragment = '$F';\nfunction normalizeEventName(name) {\n    return name.substr(2).toLowerCase();\n}\nfunction appendChild(parentDOM, dom) {\n    parentDOM.appendChild(dom);\n}\nfunction insertOrAppend(parentDOM, newNode, nextNode) {\n    if (isNull(nextNode)) {\n        appendChild(parentDOM, newNode);\n    }\n    else {\n        parentDOM.insertBefore(newNode, nextNode);\n    }\n}\nfunction documentCreateElement(tag, isSVG) {\n    if (isSVG) {\n        return document.createElementNS('http://www.w3.org/2000/svg', tag);\n    }\n    return document.createElement(tag);\n}\nfunction replaceChild(parentDOM, newDom, lastDom) {\n    parentDOM.replaceChild(newDom, lastDom);\n}\nfunction removeChild(parentDOM, childNode) {\n    parentDOM.removeChild(childNode);\n}\nfunction callAll(arrayFn) {\n    for (var i = 0; i < arrayFn.length; i++) {\n        arrayFn[i]();\n    }\n}\nfunction findChildVNode(vNode, startEdge, flags) {\n    var children = vNode.children;\n    if (flags & 4 /* ComponentClass */) {\n        return children.$LI;\n    }\n    if (flags & 8192 /* Fragment */) {\n        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];\n    }\n    return children;\n}\nfunction findDOMfromVNode(vNode, startEdge) {\n    var flags;\n    while (vNode) {\n        flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            return vNode.dom;\n        }\n        vNode = findChildVNode(vNode, startEdge, flags);\n    }\n    return null;\n}\nfunction removeVNodeDOM(vNode, parentDOM) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            removeChild(parentDOM, vNode.dom);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    removeVNodeDOM(children[i], parentDOM);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction moveVNodeDOM(vNode, parentDOM, nextNode) {\n    do {\n        var flags = vNode.flags;\n        if (flags & 2033 /* DOMRef */) {\n            insertOrAppend(parentDOM, vNode.dom, nextNode);\n            return;\n        }\n        var children = vNode.children;\n        if (flags & 4 /* ComponentClass */) {\n            vNode = children.$LI;\n        }\n        if (flags & 8 /* ComponentFunction */) {\n            vNode = children;\n        }\n        if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n                vNode = children;\n            }\n            else {\n                for (var i = 0, len = children.length; i < len; ++i) {\n                    moveVNodeDOM(children[i], parentDOM, nextNode);\n                }\n                return;\n            }\n        }\n    } while (vNode);\n}\nfunction createDerivedState(instance, nextProps, state) {\n    if (instance.constructor.getDerivedStateFromProps) {\n        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));\n    }\n    return state;\n}\nvar renderCheck = {\n    v: false\n};\nvar options = {\n    componentComparator: null,\n    createVNode: null,\n    renderComplete: null\n};\nfunction setTextContent(dom, children) {\n    dom.textContent = children;\n}\n// Calling this function assumes, nextValue is linkEvent\nfunction isLastValueSameLinkEvent(lastValue, nextValue) {\n    return (isLinkEventObject(lastValue) &&\n        lastValue.event === nextValue.event &&\n        lastValue.data === nextValue.data);\n}\nfunction mergeUnsetProperties(to, from) {\n    for (var propName in from) {\n        if (isUndefined(to[propName])) {\n            to[propName] = from[propName];\n        }\n    }\n    return to;\n}\nfunction safeCall1(method, arg1) {\n    return !!isFunction(method) && (method(arg1), true);\n}\n\nvar keyPrefix = '$';\nfunction V(childFlags, children, className, flags, key, props, ref, type) {\n    this.childFlags = childFlags;\n    this.children = children;\n    this.className = className;\n    this.dom = null;\n    this.flags = flags;\n    this.key = key === void 0 ? null : key;\n    this.props = props === void 0 ? null : props;\n    this.ref = ref === void 0 ? null : ref;\n    this.type = type;\n}\nfunction createVNode(flags, type, className, children, childFlags, props, key, ref) {\n    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;\n    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    if (childFlag === 0 /* UnknownChildren */) {\n        normalizeChildren(vNode, vNode.children);\n    }\n    return vNode;\n}\nfunction mergeDefaultHooks(flags, type, ref) {\n    if (flags & 4 /* ComponentClass */) {\n        return ref;\n    }\n    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;\n    if (isNullOrUndef(defaultHooks)) {\n        return ref;\n    }\n    if (isNullOrUndef(ref)) {\n        return defaultHooks;\n    }\n    return mergeUnsetProperties(ref, defaultHooks);\n}\nfunction mergeDefaultProps(flags, type, props) {\n    // set default props\n    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;\n    if (isNullOrUndef(defaultProps)) {\n        return props;\n    }\n    if (isNullOrUndef(props)) {\n        return combineFrom(defaultProps, null);\n    }\n    return mergeUnsetProperties(props, defaultProps);\n}\nfunction resolveComponentFlags(flags, type) {\n    if (flags & 12 /* ComponentKnown */) {\n        return flags;\n    }\n    if (type.prototype && type.prototype.render) {\n        return 4 /* ComponentClass */;\n    }\n    if (type.render) {\n        return 32776 /* ForwardRefComponent */;\n    }\n    return 8 /* ComponentFunction */;\n}\nfunction createComponentVNode(flags, type, props, key, ref) {\n    flags = resolveComponentFlags(flags, type);\n    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);\n    if (options.createVNode) {\n        options.createVNode(vNode);\n    }\n    return vNode;\n}\nfunction createTextVNode(text, key) {\n    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);\n}\nfunction createFragment(children, childFlags, key) {\n    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);\n    switch (fragment.childFlags) {\n        case 1 /* HasInvalidChildren */:\n            fragment.children = createVoidVNode();\n            fragment.childFlags = 2 /* HasVNodeChildren */;\n            break;\n        case 16 /* HasTextChildren */:\n            fragment.children = [createTextVNode(children)];\n            fragment.childFlags = 4 /* HasNonKeyedChildren */;\n            break;\n    }\n    return fragment;\n}\nfunction normalizeProps(vNode) {\n    var props = vNode.props;\n    if (props) {\n        var flags = vNode.flags;\n        if (flags & 481 /* Element */) {\n            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {\n                normalizeChildren(vNode, props.children);\n            }\n            if (props.className !== void 0) {\n                if (isNullOrUndef(vNode.className)) {\n                    vNode.className = props.className || null;\n                }\n                props.className = undefined;\n            }\n        }\n        if (props.key !== void 0) {\n            vNode.key = props.key;\n            props.key = undefined;\n        }\n        if (props.ref !== void 0) {\n            if (flags & 8 /* ComponentFunction */) {\n                vNode.ref = combineFrom(vNode.ref, props.ref);\n            }\n            else {\n                vNode.ref = props.ref;\n            }\n            props.ref = undefined;\n        }\n    }\n    return vNode;\n}\n/*\n * Fragment is different than normal vNode,\n * because when it needs to be cloned we need to clone its children too\n * But not normalize, because otherwise those possibly get KEY and re-mount\n */\nfunction cloneFragment(vNodeToClone) {\n    var oldChildren = vNodeToClone.children;\n    var childFlags = vNodeToClone.childFlags;\n    return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);\n}\nfunction directClone(vNodeToClone) {\n    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;\n    var props = vNodeToClone.props;\n    if (flags & 14 /* Component */) {\n        if (!isNull(props)) {\n            var propsToClone = props;\n            props = {};\n            for (var key in propsToClone) {\n                props[key] = propsToClone[key];\n            }\n        }\n    }\n    if ((flags & 8192 /* Fragment */) === 0) {\n        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);\n    }\n    return cloneFragment(vNodeToClone);\n}\nfunction createVoidVNode() {\n    return createTextVNode('', null);\n}\nfunction createPortal(children, container) {\n    var normalizedRoot = normalizeRoot(children);\n    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);\n}\nfunction _normalizeVNodes(nodes, result, index, currentKey) {\n    for (var len = nodes.length; index < len; index++) {\n        var n = nodes[index];\n        if (!isInvalid(n)) {\n            var newKey = currentKey + keyPrefix + index;\n            if (isArray(n)) {\n                _normalizeVNodes(n, result, 0, newKey);\n            }\n            else {\n                if (isStringOrNumber(n)) {\n                    n = createTextVNode(n, newKey);\n                }\n                else {\n                    var oldKey = n.key;\n                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;\n                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {\n                        n = directClone(n);\n                    }\n                    n.flags |= 65536 /* Normalized */;\n                    if (!isPrefixedKey) {\n                        if (isNull(oldKey)) {\n                            n.key = newKey;\n                        }\n                        else {\n                            n.key = currentKey + oldKey;\n                        }\n                    }\n                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {\n                        n.key = currentKey + oldKey;\n                    }\n                }\n                result.push(n);\n            }\n        }\n    }\n}\nfunction getFlagsForElementVnode(type) {\n    switch (type) {\n        case 'svg':\n            return 32 /* SvgElement */;\n        case 'input':\n            return 64 /* InputElement */;\n        case 'select':\n            return 256 /* SelectElement */;\n        case 'textarea':\n            return 128 /* TextareaElement */;\n        case Fragment:\n            return 8192 /* Fragment */;\n        default:\n            return 1 /* HtmlElement */;\n    }\n}\nfunction normalizeChildren(vNode, children) {\n    var newChildren;\n    var newChildFlags = 1 /* HasInvalidChildren */;\n    // Don't change children to match strict equal (===) true in patching\n    if (isInvalid(children)) {\n        newChildren = children;\n    }\n    else if (isStringOrNumber(children)) {\n        newChildFlags = 16 /* HasTextChildren */;\n        newChildren = children;\n    }\n    else if (isArray(children)) {\n        var len = children.length;\n        for (var i = 0; i < len; ++i) {\n            var n = children[i];\n            if (isInvalid(n) || isArray(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                _normalizeVNodes(children, newChildren, i, '');\n                break;\n            }\n            else if (isStringOrNumber(n)) {\n                newChildren = newChildren || children.slice(0, i);\n                newChildren.push(createTextVNode(n, keyPrefix + i));\n            }\n            else {\n                var key = n.key;\n                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;\n                var isNullKey = isNull(key);\n                var isPrefixed = isString(key) && key[0] === keyPrefix;\n                if (needsCloning || isNullKey || isPrefixed) {\n                    newChildren = newChildren || children.slice(0, i);\n                    if (needsCloning || isPrefixed) {\n                        n = directClone(n);\n                    }\n                    if (isNullKey || isPrefixed) {\n                        n.key = keyPrefix + i;\n                    }\n                    newChildren.push(n);\n                }\n                else if (newChildren) {\n                    newChildren.push(n);\n                }\n                n.flags |= 65536 /* Normalized */;\n            }\n        }\n        newChildren = newChildren || children;\n        if (newChildren.length === 0) {\n            newChildFlags = 1 /* HasInvalidChildren */;\n        }\n        else {\n            newChildFlags = 8 /* HasKeyedChildren */;\n        }\n    }\n    else {\n        newChildren = children;\n        newChildren.flags |= 65536 /* Normalized */;\n        if (children.flags & 81920 /* InUseOrNormalized */) {\n            newChildren = directClone(children);\n        }\n        newChildFlags = 2 /* HasVNodeChildren */;\n    }\n    vNode.children = newChildren;\n    vNode.childFlags = newChildFlags;\n    return vNode;\n}\nfunction normalizeRoot(input) {\n    if (isInvalid(input) || isStringOrNumber(input)) {\n        return createTextVNode(input, null);\n    }\n    if (isArray(input)) {\n        return createFragment(input, 0 /* UnknownChildren */, null);\n    }\n    return input.flags & 16384 /* InUse */ ? directClone(input) : input;\n}\n\nvar xlinkNS = 'http://www.w3.org/1999/xlink';\nvar xmlNS = 'http://www.w3.org/XML/1998/namespace';\nvar namespaces = {\n    'xlink:actuate': xlinkNS,\n    'xlink:arcrole': xlinkNS,\n    'xlink:href': xlinkNS,\n    'xlink:role': xlinkNS,\n    'xlink:show': xlinkNS,\n    'xlink:title': xlinkNS,\n    'xlink:type': xlinkNS,\n    'xml:base': xmlNS,\n    'xml:lang': xmlNS,\n    'xml:space': xmlNS\n};\n\nfunction getDelegatedEventObject(v) {\n    return {\n        onClick: v,\n        onDblClick: v,\n        onFocusIn: v,\n        onFocusOut: v,\n        onKeyDown: v,\n        onKeyPress: v,\n        onKeyUp: v,\n        onMouseDown: v,\n        onMouseMove: v,\n        onMouseUp: v,\n        onTouchEnd: v,\n        onTouchMove: v,\n        onTouchStart: v\n    };\n}\nvar attachedEventCounts = getDelegatedEventObject(0);\nvar attachedEvents = getDelegatedEventObject(null);\nvar syntheticEvents = getDelegatedEventObject(true);\nfunction updateOrAddSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (!eventsObject) {\n        eventsObject = dom.$EV = getDelegatedEventObject(null);\n    }\n    if (!eventsObject[name]) {\n        if (++attachedEventCounts[name] === 1) {\n            attachedEvents[name] = attachEventToDocument(name);\n        }\n    }\n    return eventsObject;\n}\nfunction unmountSyntheticEvent(name, dom) {\n    var eventsObject = dom.$EV;\n    if (eventsObject && eventsObject[name]) {\n        if (--attachedEventCounts[name] === 0) {\n            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);\n            attachedEvents[name] = null;\n        }\n        eventsObject[name] = null;\n    }\n}\nfunction handleSyntheticEvent(name, lastEvent, nextEvent, dom) {\n    if (isFunction(nextEvent)) {\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else if (isLinkEventObject(nextEvent)) {\n        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {\n            return;\n        }\n        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;\n    }\n    else {\n        unmountSyntheticEvent(name, dom);\n    }\n}\n// When browsers fully support event.composedPath we could loop it through instead of using parentNode property\nfunction getTargetNode(event) {\n    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;\n}\nfunction dispatchEvents(event, isClick, name, eventData) {\n    var dom = getTargetNode(event);\n    do {\n        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,\n        // because the event listener is on document.body\n        // Don't process clicks on disabled elements\n        if (isClick && dom.disabled) {\n            return;\n        }\n        var eventsObject = dom.$EV;\n        if (eventsObject) {\n            var currentEvent = eventsObject[name];\n            if (currentEvent) {\n                // linkEvent object\n                eventData.dom = dom;\n                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);\n                if (event.cancelBubble) {\n                    return;\n                }\n            }\n        }\n        dom = dom.parentNode;\n    } while (!isNull(dom));\n}\nfunction stopPropagation() {\n    this.cancelBubble = true;\n    if (!this.immediatePropagationStopped) {\n        this.stopImmediatePropagation();\n    }\n}\nfunction isDefaultPrevented() {\n    return this.defaultPrevented;\n}\nfunction isPropagationStopped() {\n    return this.cancelBubble;\n}\nfunction extendEventProperties(event) {\n    // Event data needs to be object to save reference to currentTarget getter\n    var eventData = {\n        dom: document\n    };\n    event.isDefaultPrevented = isDefaultPrevented;\n    event.isPropagationStopped = isPropagationStopped;\n    event.stopPropagation = stopPropagation;\n    Object.defineProperty(event, 'currentTarget', {\n        configurable: true,\n        get: function get() {\n            return eventData.dom;\n        }\n    });\n    return eventData;\n}\nfunction rootClickEvent(name) {\n    return function (event) {\n        if (event.button !== 0) {\n            // Firefox incorrectly triggers click event for mid/right mouse buttons.\n            // This bug has been active for 17 years.\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051\n            event.stopPropagation();\n            return;\n        }\n        dispatchEvents(event, true, name, extendEventProperties(event));\n    };\n}\nfunction rootEvent(name) {\n    return function (event) {\n        dispatchEvents(event, false, name, extendEventProperties(event));\n    };\n}\nfunction attachEventToDocument(name) {\n    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);\n    document.addEventListener(normalizeEventName(name), attachedEvent);\n    return attachedEvent;\n}\n\nfunction isSameInnerHTML(dom, innerHTML) {\n    var tempdom = document.createElement('i');\n    tempdom.innerHTML = innerHTML;\n    return tempdom.innerHTML === dom.innerHTML;\n}\n\nfunction triggerEventListener(props, methodName, e) {\n    if (props[methodName]) {\n        var listener = props[methodName];\n        if (listener.event) {\n            listener.event(listener.data, e);\n        }\n        else {\n            listener(e);\n        }\n    }\n    else {\n        var nativeListenerName = methodName.toLowerCase();\n        if (props[nativeListenerName]) {\n            props[nativeListenerName](e);\n        }\n    }\n}\nfunction createWrappedFunction(methodName, applyValue) {\n    var fnMethod = function (e) {\n        var vNode = this.$V;\n        // If vNode is gone by the time event fires, no-op\n        if (!vNode) {\n            return;\n        }\n        var props = vNode.props || EMPTY_OBJ;\n        var dom = vNode.dom;\n        if (isString(methodName)) {\n            triggerEventListener(props, methodName, e);\n        }\n        else {\n            for (var i = 0; i < methodName.length; ++i) {\n                triggerEventListener(props, methodName[i], e);\n            }\n        }\n        if (isFunction(applyValue)) {\n            var newVNode = this.$V;\n            var newProps = newVNode.props || EMPTY_OBJ;\n            applyValue(newProps, dom, false, newVNode);\n        }\n    };\n    Object.defineProperty(fnMethod, 'wrapped', {\n        configurable: false,\n        enumerable: false,\n        value: true,\n        writable: false\n    });\n    return fnMethod;\n}\n\nfunction attachEvent(dom, eventName, handler) {\n    var previousKey = \"$\" + eventName;\n    var previousArgs = dom[previousKey];\n    if (previousArgs) {\n        if (previousArgs[1].wrapped) {\n            return;\n        }\n        dom.removeEventListener(previousArgs[0], previousArgs[1]);\n        dom[previousKey] = null;\n    }\n    if (isFunction(handler)) {\n        dom.addEventListener(eventName, handler);\n        dom[previousKey] = [eventName, handler];\n    }\n}\n\nfunction isCheckedType(type) {\n    return type === 'checkbox' || type === 'radio';\n}\nvar onTextInputChange = createWrappedFunction('onInput', applyValueInput);\nvar wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);\n/* tslint:disable-next-line:no-empty */\nfunction emptywrapper(event) {\n    event.stopPropagation();\n}\nemptywrapper.wrapped = true;\nfunction inputEvents(dom, nextPropsOrEmpty) {\n    if (isCheckedType(nextPropsOrEmpty.type)) {\n        attachEvent(dom, 'change', wrappedOnChange);\n        attachEvent(dom, 'click', emptywrapper);\n    }\n    else {\n        attachEvent(dom, 'input', onTextInputChange);\n    }\n}\nfunction applyValueInput(nextPropsOrEmpty, dom) {\n    var type = nextPropsOrEmpty.type;\n    var value = nextPropsOrEmpty.value;\n    var checked = nextPropsOrEmpty.checked;\n    var multiple = nextPropsOrEmpty.multiple;\n    var defaultValue = nextPropsOrEmpty.defaultValue;\n    var hasValue = !isNullOrUndef(value);\n    if (type && type !== dom.type) {\n        dom.setAttribute('type', type);\n    }\n    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {\n        dom.multiple = multiple;\n    }\n    if (!isNullOrUndef(defaultValue) && !hasValue) {\n        dom.defaultValue = defaultValue + '';\n    }\n    if (isCheckedType(type)) {\n        if (hasValue) {\n            dom.value = value;\n        }\n        if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n    else {\n        if (hasValue && dom.value !== value) {\n            dom.defaultValue = value;\n            dom.value = value;\n        }\n        else if (!isNullOrUndef(checked)) {\n            dom.checked = checked;\n        }\n    }\n}\n\nfunction updateChildOptions(vNode, value) {\n    if (vNode.type === 'option') {\n        updateChildOption(vNode, value);\n    }\n    else {\n        var children = vNode.children;\n        var flags = vNode.flags;\n        if (flags & 4 /* ComponentClass */) {\n            updateChildOptions(children.$LI, value);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {\n            updateChildOptions(children, value);\n        }\n        else if (vNode.childFlags & 12 /* MultipleChildren */) {\n            for (var i = 0, len = children.length; i < len; ++i) {\n                updateChildOptions(children[i], value);\n            }\n        }\n    }\n}\nfunction updateChildOption(vNode, value) {\n    var props = vNode.props || EMPTY_OBJ;\n    var dom = vNode.dom;\n    // we do this as multiple may have changed\n    dom.value = props.value;\n    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {\n        dom.selected = true;\n    }\n    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {\n        dom.selected = props.selected || false;\n    }\n}\nvar onSelectChange = createWrappedFunction('onChange', applyValueSelect);\nfunction selectEvents(dom) {\n    attachEvent(dom, 'change', onSelectChange);\n}\nfunction applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {\n    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);\n    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {\n        dom.multiple = multiplePropInBoolean;\n    }\n    var index = nextPropsOrEmpty.selectedIndex;\n    if (index === -1) {\n        dom.selectedIndex = -1;\n    }\n    var childFlags = vNode.childFlags;\n    if (childFlags !== 1 /* HasInvalidChildren */) {\n        var value = nextPropsOrEmpty.value;\n        if (isNumber(index) && index > -1 && dom.options[index]) {\n            value = dom.options[index].value;\n        }\n        if (mounting && isNullOrUndef(value)) {\n            value = nextPropsOrEmpty.defaultValue;\n        }\n        updateChildOptions(vNode, value);\n    }\n}\n\nvar onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);\nvar wrappedOnChange$1 = createWrappedFunction('onChange');\nfunction textAreaEvents(dom, nextPropsOrEmpty) {\n    attachEvent(dom, 'input', onTextareaInputChange);\n    if (nextPropsOrEmpty.onChange) {\n        attachEvent(dom, 'change', wrappedOnChange$1);\n    }\n}\nfunction applyValueTextArea(nextPropsOrEmpty, dom, mounting) {\n    var value = nextPropsOrEmpty.value;\n    var domValue = dom.value;\n    if (isNullOrUndef(value)) {\n        if (mounting) {\n            var defaultValue = nextPropsOrEmpty.defaultValue;\n            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {\n                dom.defaultValue = defaultValue;\n                dom.value = defaultValue;\n            }\n        }\n    }\n    else if (domValue !== value) {\n        /* There is value so keep it controlled */\n        dom.defaultValue = value;\n        dom.value = value;\n    }\n}\n\nfunction processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {\n    if (flags & 64 /* InputElement */) {\n        applyValueInput(nextPropsOrEmpty, dom);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        applyValueTextArea(nextPropsOrEmpty, dom, mounting);\n    }\n    if (isControlled) {\n        dom.$V = vNode;\n    }\n}\nfunction addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {\n    if (flags & 64 /* InputElement */) {\n        inputEvents(dom, nextPropsOrEmpty);\n    }\n    else if (flags & 256 /* SelectElement */) {\n        selectEvents(dom);\n    }\n    else if (flags & 128 /* TextareaElement */) {\n        textAreaEvents(dom, nextPropsOrEmpty);\n    }\n}\nfunction isControlledFormElement(nextPropsOrEmpty) {\n    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);\n}\n\nfunction createRef() {\n    return {\n        current: null\n    };\n}\nfunction forwardRef(render) {\n    // @ts-ignore\n    return {\n        render: render\n    };\n}\nfunction unmountRef(ref) {\n    if (ref) {\n        if (!safeCall1(ref, null) && ref.current) {\n            ref.current = null;\n        }\n    }\n}\nfunction mountRef(ref, value, lifecycle) {\n    if (ref && (isFunction(ref) || ref.current !== void 0)) {\n        lifecycle.push(function () {\n            if (!safeCall1(ref, value) && ref.current !== void 0) {\n                ref.current = value;\n            }\n        });\n    }\n}\n\nfunction remove(vNode, parentDOM) {\n    unmount(vNode);\n    removeVNodeDOM(vNode, parentDOM);\n}\nfunction unmount(vNode) {\n    var flags = vNode.flags;\n    var children = vNode.children;\n    var ref;\n    if (flags & 481 /* Element */) {\n        ref = vNode.ref;\n        var props = vNode.props;\n        unmountRef(ref);\n        var childFlags = vNode.childFlags;\n        if (!isNull(props)) {\n            var keys = Object.keys(props);\n            for (var i = 0, len = keys.length; i < len; i++) {\n                var key = keys[i];\n                if (syntheticEvents[key]) {\n                    unmountSyntheticEvent(key, vNode.dom);\n                }\n            }\n        }\n        if (childFlags & 12 /* MultipleChildren */) {\n            unmountAllChildren(children);\n        }\n        else if (childFlags === 2 /* HasVNodeChildren */) {\n            unmount(children);\n        }\n    }\n    else if (children) {\n        if (flags & 4 /* ComponentClass */) {\n            if (isFunction(children.componentWillUnmount)) {\n                children.componentWillUnmount();\n            }\n            unmountRef(vNode.ref);\n            children.$UN = true;\n            unmount(children.$LI);\n        }\n        else if (flags & 8 /* ComponentFunction */) {\n            ref = vNode.ref;\n            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {\n                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n            }\n            unmount(children);\n        }\n        else if (flags & 1024 /* Portal */) {\n            remove(children, vNode.ref);\n        }\n        else if (flags & 8192 /* Fragment */) {\n            if (vNode.childFlags & 12 /* MultipleChildren */) {\n                unmountAllChildren(children);\n            }\n        }\n    }\n}\nfunction unmountAllChildren(children) {\n    for (var i = 0, len = children.length; i < len; ++i) {\n        unmount(children[i]);\n    }\n}\nfunction clearDOM(dom) {\n    // Optimization for clearing dom\n    dom.textContent = '';\n}\nfunction removeAllChildren(dom, vNode, children) {\n    unmountAllChildren(children);\n    if (vNode.flags & 8192 /* Fragment */) {\n        removeVNodeDOM(vNode, dom);\n    }\n    else {\n        clearDOM(dom);\n    }\n}\n\nfunction wrapLinkEvent(nextValue) {\n    // This variable makes sure there is no \"this\" context in callback\n    var ev = nextValue.event;\n    return function (e) {\n        ev(nextValue.data, e);\n    };\n}\nfunction patchEvent(name, lastValue, nextValue, dom) {\n    if (isLinkEventObject(nextValue)) {\n        if (isLastValueSameLinkEvent(lastValue, nextValue)) {\n            return;\n        }\n        nextValue = wrapLinkEvent(nextValue);\n    }\n    attachEvent(dom, normalizeEventName(name), nextValue);\n}\n// We are assuming here that we come from patchProp routine\n// -nextAttrValue cannot be null or undefined\nfunction patchStyle(lastAttrValue, nextAttrValue, dom) {\n    if (isNullOrUndef(nextAttrValue)) {\n        dom.removeAttribute('style');\n        return;\n    }\n    var domStyle = dom.style;\n    var style;\n    var value;\n    if (isString(nextAttrValue)) {\n        domStyle.cssText = nextAttrValue;\n        return;\n    }\n    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {\n        for (style in nextAttrValue) {\n            // do not add a hasOwnProperty check here, it affects performance\n            value = nextAttrValue[style];\n            if (value !== lastAttrValue[style]) {\n                domStyle.setProperty(style, value);\n            }\n        }\n        for (style in lastAttrValue) {\n            if (isNullOrUndef(nextAttrValue[style])) {\n                domStyle.removeProperty(style);\n            }\n        }\n    }\n    else {\n        for (style in nextAttrValue) {\n            value = nextAttrValue[style];\n            domStyle.setProperty(style, value);\n        }\n    }\n}\nfunction patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {\n    var lastHtml = (lastValue && lastValue.__html) || '';\n    var nextHtml = (nextValue && nextValue.__html) || '';\n    if (lastHtml !== nextHtml) {\n        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {\n            if (!isNull(lastVNode)) {\n                if (lastVNode.childFlags & 12 /* MultipleChildren */) {\n                    unmountAllChildren(lastVNode.children);\n                }\n                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {\n                    unmount(lastVNode.children);\n                }\n                lastVNode.children = null;\n                lastVNode.childFlags = 1 /* HasInvalidChildren */;\n            }\n            dom.innerHTML = nextHtml;\n        }\n    }\n}\nfunction patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {\n    switch (prop) {\n        case 'children':\n        case 'childrenType':\n        case 'className':\n        case 'defaultValue':\n        case 'key':\n        case 'multiple':\n        case 'ref':\n        case 'selectedIndex':\n            break;\n        case 'autoFocus':\n            dom.autofocus = !!nextValue;\n            break;\n        case 'allowfullscreen':\n        case 'autoplay':\n        case 'capture':\n        case 'checked':\n        case 'controls':\n        case 'default':\n        case 'disabled':\n        case 'hidden':\n        case 'indeterminate':\n        case 'loop':\n        case 'muted':\n        case 'novalidate':\n        case 'open':\n        case 'readOnly':\n        case 'required':\n        case 'reversed':\n        case 'scoped':\n        case 'seamless':\n        case 'selected':\n            dom[prop] = !!nextValue;\n            break;\n        case 'defaultChecked':\n        case 'value':\n        case 'volume':\n            if (hasControlledValue && prop === 'value') {\n                break;\n            }\n            var value = isNullOrUndef(nextValue) ? '' : nextValue;\n            if (dom[prop] !== value) {\n                dom[prop] = value;\n            }\n            break;\n        case 'style':\n            patchStyle(lastValue, nextValue, dom);\n            break;\n        case 'dangerouslySetInnerHTML':\n            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);\n            break;\n        default:\n            if (syntheticEvents[prop]) {\n                handleSyntheticEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {\n                patchEvent(prop, lastValue, nextValue, dom);\n            }\n            else if (isNullOrUndef(nextValue)) {\n                dom.removeAttribute(prop);\n            }\n            else if (isSVG && namespaces[prop]) {\n                // We optimize for isSVG being false\n                // If we end up in this path we can read property again\n                dom.setAttributeNS(namespaces[prop], prop, nextValue);\n            }\n            else {\n                dom.setAttribute(prop, nextValue);\n            }\n            break;\n    }\n}\nfunction mountProps(vNode, flags, props, dom, isSVG) {\n    var hasControlledValue = false;\n    var isFormElement = (flags & 448 /* FormElement */) > 0;\n    if (isFormElement) {\n        hasControlledValue = isControlledFormElement(props);\n        if (hasControlledValue) {\n            addFormElementEventHandlers(flags, dom, props);\n        }\n    }\n    for (var prop in props) {\n        // do not add a hasOwnProperty check here, it affects performance\n        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);\n    }\n    if (isFormElement) {\n        processElement(flags, vNode, dom, props, true, hasControlledValue);\n    }\n}\n\nfunction renderNewInput(instance, props, context) {\n    var nextInput = normalizeRoot(instance.render(props, instance.state, context));\n    var childContext = context;\n    if (isFunction(instance.getChildContext)) {\n        childContext = combineFrom(context, instance.getChildContext());\n    }\n    instance.$CX = childContext;\n    return nextInput;\n}\nfunction createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {\n    var instance = new Component(props, context);\n    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));\n    instance.$SVG = isSVG;\n    instance.$L = lifecycle;\n    vNode.children = instance;\n    instance.$BS = false;\n    instance.context = context;\n    if (instance.props === EMPTY_OBJ) {\n        instance.props = props;\n    }\n    if (!usesNewAPI) {\n        if (isFunction(instance.componentWillMount)) {\n            instance.$BR = true;\n            instance.componentWillMount();\n            var pending = instance.$PS;\n            if (!isNull(pending)) {\n                var state = instance.state;\n                if (isNull(state)) {\n                    instance.state = pending;\n                }\n                else {\n                    for (var key in pending) {\n                        state[key] = pending[key];\n                    }\n                }\n                instance.$PS = null;\n            }\n            instance.$BR = false;\n        }\n    }\n    else {\n        instance.state = createDerivedState(instance, props, instance.state);\n    }\n    instance.$LI = renderNewInput(instance, props, context);\n    return instance;\n}\nfunction renderFunctionalComponent(vNode, context) {\n    var props = vNode.props || EMPTY_OBJ;\n    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);\n}\n\nfunction mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = (vNode.flags |= 16384 /* InUse */);\n    if (flags & 481 /* Element */) {\n        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 4 /* ComponentClass */) {\n        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 8 /* ComponentFunction */) {\n        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        mountFunctionalComponentCallbacks(vNode, lifecycle);\n    }\n    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {\n        mountText(vNode, parentDOM, nextNode);\n    }\n    else if (flags & 8192 /* Fragment */) {\n        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);\n    }\n    else if (flags & 1024 /* Portal */) {\n        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);\n    }\n    else ;\n}\nfunction mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {\n    mount(vNode.children, vNode.ref, context, false, null, lifecycle);\n    var placeHolderVNode = createVoidVNode();\n    mountText(placeHolderVNode, parentDOM, nextNode);\n    vNode.dom = placeHolderVNode.dom;\n}\nfunction mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {\n    var children = vNode.children;\n    var childFlags = vNode.childFlags;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {\n        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;\n        children = vNode.children = createVoidVNode();\n    }\n    if (childFlags === 2 /* HasVNodeChildren */) {\n        mount(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else {\n        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountText(vNode, parentDOM, nextNode) {\n    var dom = (vNode.dom = document.createTextNode(vNode.children));\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n}\nfunction mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var flags = vNode.flags;\n    var props = vNode.props;\n    var className = vNode.className;\n    var childFlags = vNode.childFlags;\n    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));\n    var children = vNode.children;\n    if (!isNullOrUndef(className) && className !== '') {\n        if (isSVG) {\n            dom.setAttribute('class', className);\n        }\n        else {\n            dom.className = className;\n        }\n    }\n    if (childFlags === 16 /* HasTextChildren */) {\n        setTextContent(dom, children);\n    }\n    else if (childFlags !== 1 /* HasInvalidChildren */) {\n        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';\n        if (childFlags === 2 /* HasVNodeChildren */) {\n            if (children.flags & 16384 /* InUse */) {\n                vNode.children = children = directClone(children);\n            }\n            mount(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {\n            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);\n        }\n    }\n    if (!isNull(parentDOM)) {\n        insertOrAppend(parentDOM, dom, nextNode);\n    }\n    if (!isNull(props)) {\n        mountProps(vNode, flags, props, dom, isSVG);\n    }\n    mountRef(vNode.ref, dom, lifecycle);\n}\nfunction mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {\n    for (var i = 0; i < children.length; ++i) {\n        var child = children[i];\n        if (child.flags & 16384 /* InUse */) {\n            children[i] = child = directClone(child);\n        }\n        mount(child, dom, context, isSVG, nextNode, lifecycle);\n    }\n}\nfunction mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);\n    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);\n}\nfunction mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);\n}\nfunction createClassMountCallback(instance) {\n    return function () {\n        instance.componentDidMount();\n    };\n}\nfunction mountClassComponentCallbacks(ref, instance, lifecycle) {\n    mountRef(ref, instance, lifecycle);\n    if (isFunction(instance.componentDidMount)) {\n        lifecycle.push(createClassMountCallback(instance));\n    }\n}\nfunction createOnMountCallback(ref, vNode) {\n    return function () {\n        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);\n    };\n}\nfunction mountFunctionalComponentCallbacks(vNode, lifecycle) {\n    var ref = vNode.ref;\n    if (!isNullOrUndef(ref)) {\n        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);\n        if (isFunction(ref.onComponentDidMount)) {\n            lifecycle.push(createOnMountCallback(ref, vNode));\n        }\n    }\n}\n\nfunction replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastVNode);\n    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {\n        mount(nextVNode, null, context, isSVG, null, lifecycle);\n        // Single DOM operation, when we have dom references available\n        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);\n    }\n    else {\n        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);\n        removeVNodeDOM(lastVNode, parentDOM);\n    }\n}\nfunction patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);\n    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {\n        if (lastVNode.flags & 16384 /* InUse */) {\n            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n        }\n        else {\n            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one\n            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (nextFlags & 481 /* Element */) {\n        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);\n    }\n    else if (nextFlags & 4 /* ComponentClass */) {\n        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 8 /* ComponentFunction */) {\n        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);\n    }\n    else if (nextFlags & 16 /* Text */) {\n        patchText(lastVNode, nextVNode);\n    }\n    else if (nextFlags & 512 /* Void */) {\n        nextVNode.dom = lastVNode.dom;\n    }\n    else if (nextFlags & 8192 /* Fragment */) {\n        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);\n    }\n    else {\n        patchPortal(lastVNode, nextVNode, context, lifecycle);\n    }\n}\nfunction patchSingleTextChild(lastChildren, nextChildren, parentDOM) {\n    if (lastChildren !== nextChildren) {\n        if (lastChildren !== '') {\n            parentDOM.firstChild.nodeValue = nextChildren;\n        }\n        else {\n            setTextContent(parentDOM, nextChildren);\n        }\n    }\n}\nfunction patchContentEditableChildren(dom, nextChildren) {\n    if (dom.textContent !== nextChildren) {\n        dom.textContent = nextChildren;\n    }\n}\nfunction patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {\n    var lastChildren = lastVNode.children;\n    var nextChildren = nextVNode.children;\n    var lastChildFlags = lastVNode.childFlags;\n    var nextChildFlags = nextVNode.childFlags;\n    var nextNode = null;\n    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid\n    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements\n    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {\n        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;\n        nextChildren = nextVNode.children = createVoidVNode();\n    }\n    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;\n    if (lastChildFlags & 12 /* MultipleChildren */) {\n        var lastLen = lastChildren.length;\n        // We need to know Fragment's edge node when\n        if (\n        // It uses keyed algorithm\n        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||\n            // It transforms from many to single\n            nextIsSingle ||\n            // It will append more nodes\n            (!nextIsSingle && nextChildren.length > lastLen)) {\n            // When fragment has multiple children there is always at least one vNode\n            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;\n        }\n    }\n    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);\n}\nfunction patchPortal(lastVNode, nextVNode, context, lifecycle) {\n    var lastContainer = lastVNode.ref;\n    var nextContainer = nextVNode.ref;\n    var nextChildren = nextVNode.children;\n    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);\n    nextVNode.dom = lastVNode.dom;\n    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {\n        var node = nextChildren.dom;\n        removeChild(lastContainer, node);\n        appendChild(nextContainer, node);\n    }\n}\nfunction patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {\n    var dom = (nextVNode.dom = lastVNode.dom);\n    var lastProps = lastVNode.props;\n    var nextProps = nextVNode.props;\n    var isFormElement = false;\n    var hasControlledValue = false;\n    var nextPropsOrEmpty;\n    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;\n    // inlined patchProps  -- starts --\n    if (lastProps !== nextProps) {\n        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;\n        nextPropsOrEmpty = nextProps || EMPTY_OBJ;\n        if (nextPropsOrEmpty !== EMPTY_OBJ) {\n            isFormElement = (nextFlags & 448 /* FormElement */) > 0;\n            if (isFormElement) {\n                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);\n            }\n            for (var prop in nextPropsOrEmpty) {\n                var lastValue = lastPropsOrEmpty[prop];\n                var nextValue = nextPropsOrEmpty[prop];\n                if (lastValue !== nextValue) {\n                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n        if (lastPropsOrEmpty !== EMPTY_OBJ) {\n            for (var prop$1 in lastPropsOrEmpty) {\n                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {\n                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);\n                }\n            }\n        }\n    }\n    var nextChildren = nextVNode.children;\n    var nextClassName = nextVNode.className;\n    // inlined patchProps  -- ends --\n    if (lastVNode.className !== nextClassName) {\n        if (isNullOrUndef(nextClassName)) {\n            dom.removeAttribute('class');\n        }\n        else if (isSVG) {\n            dom.setAttribute('class', nextClassName);\n        }\n        else {\n            dom.className = nextClassName;\n        }\n    }\n    if (nextFlags & 4096 /* ContentEditable */) {\n        patchContentEditableChildren(dom, nextChildren);\n    }\n    else {\n        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);\n    }\n    if (isFormElement) {\n        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);\n    }\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, dom, lifecycle);\n    }\n}\nfunction replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {\n    unmount(lastChildren);\n    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);\n    removeVNodeDOM(lastChildren, parentDOM);\n}\nfunction patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {\n    switch (lastChildFlags) {\n        case 2 /* HasVNodeChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    remove(lastChildren, parentDOM);\n                    break;\n                case 16 /* HasTextChildren */:\n                    unmount(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);\n                    break;\n            }\n            break;\n        case 1 /* HasInvalidChildren */:\n            switch (nextChildFlags) {\n                case 2 /* HasVNodeChildren */:\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    break;\n                case 16 /* HasTextChildren */:\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                default:\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        case 16 /* HasTextChildren */:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    clearDOM(parentDOM);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    clearDOM(parentDOM);\n                    break;\n                default:\n                    clearDOM(parentDOM);\n                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n            }\n            break;\n        default:\n            switch (nextChildFlags) {\n                case 16 /* HasTextChildren */:\n                    unmountAllChildren(lastChildren);\n                    setTextContent(parentDOM, nextChildren);\n                    break;\n                case 2 /* HasVNodeChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                    break;\n                case 1 /* HasInvalidChildren */:\n                    removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    break;\n                default:\n                    var lastLength = lastChildren.length | 0;\n                    var nextLength = nextChildren.length | 0;\n                    // Fast path's for both algorithms\n                    if (lastLength === 0) {\n                        if (nextLength > 0) {\n                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);\n                        }\n                    }\n                    else if (nextLength === 0) {\n                        removeAllChildren(parentDOM, parentVNode, lastChildren);\n                    }\n                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {\n                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);\n                    }\n                    else {\n                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);\n                    }\n                    break;\n            }\n            break;\n    }\n}\nfunction createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {\n    lifecycle.push(function () {\n        instance.componentDidUpdate(lastProps, lastState, snapshot);\n    });\n}\nfunction updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {\n    var lastState = instance.state;\n    var lastProps = instance.props;\n    var usesNewAPI = Boolean(instance.$N);\n    var hasSCU = isFunction(instance.shouldComponentUpdate);\n    if (usesNewAPI) {\n        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);\n    }\n    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {\n        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {\n            instance.componentWillUpdate(nextProps, nextState, context);\n        }\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n        var snapshot = null;\n        var nextInput = renderNewInput(instance, nextProps, context);\n        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {\n            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);\n        }\n        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);\n        // Dont update Last input, until patch has been succesfully executed\n        instance.$LI = nextInput;\n        if (isFunction(instance.componentDidUpdate)) {\n            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);\n        }\n    }\n    else {\n        instance.props = nextProps;\n        instance.state = nextState;\n        instance.context = context;\n    }\n}\nfunction patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var instance = (nextVNode.children = lastVNode.children);\n    // If Component has crashed, ignore it to stay functional\n    if (isNull(instance)) {\n        return;\n    }\n    instance.$L = lifecycle;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastRef = lastVNode.ref;\n    var nextState = instance.state;\n    if (!instance.$N) {\n        if (isFunction(instance.componentWillReceiveProps)) {\n            instance.$BR = true;\n            instance.componentWillReceiveProps(nextProps, context);\n            // If instance component was removed during its own update do nothing.\n            if (instance.$UN) {\n                return;\n            }\n            instance.$BR = false;\n        }\n        if (!isNull(instance.$PS)) {\n            nextState = combineFrom(nextState, instance.$PS);\n            instance.$PS = null;\n        }\n    }\n    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);\n    if (lastRef !== nextRef) {\n        unmountRef(lastRef);\n        mountRef(nextRef, instance, lifecycle);\n    }\n}\nfunction patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {\n    var shouldUpdate = true;\n    var nextProps = nextVNode.props || EMPTY_OBJ;\n    var nextRef = nextVNode.ref;\n    var lastProps = lastVNode.props;\n    var nextHooksDefined = !isNullOrUndef(nextRef);\n    var lastInput = lastVNode.children;\n    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {\n        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);\n    }\n    if (shouldUpdate !== false) {\n        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {\n            nextRef.onComponentWillUpdate(lastProps, nextProps);\n        }\n        var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));\n        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);\n        nextVNode.children = nextInput;\n        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {\n            nextRef.onComponentDidUpdate(lastProps, nextProps);\n        }\n    }\n    else {\n        nextVNode.children = lastInput;\n    }\n}\nfunction patchText(lastVNode, nextVNode) {\n    var nextText = nextVNode.children;\n    var dom = (nextVNode.dom = lastVNode.dom);\n    if (nextText !== lastVNode.children) {\n        dom.nodeValue = nextText;\n    }\n}\nfunction patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {\n    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;\n    var i = 0;\n    var nextChild;\n    var lastChild;\n    for (; i < commonLength; ++i) {\n        nextChild = nextChildren[i];\n        lastChild = lastChildren[i];\n        if (nextChild.flags & 16384 /* InUse */) {\n            nextChild = nextChildren[i] = directClone(nextChild);\n        }\n        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);\n        lastChildren[i] = nextChild;\n    }\n    if (lastChildrenLength < nextChildrenLength) {\n        for (i = commonLength; i < nextChildrenLength; ++i) {\n            nextChild = nextChildren[i];\n            if (nextChild.flags & 16384 /* InUse */) {\n                nextChild = nextChildren[i] = directClone(nextChild);\n            }\n            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);\n        }\n    }\n    else if (lastChildrenLength > nextChildrenLength) {\n        for (i = commonLength; i < lastChildrenLength; ++i) {\n            remove(lastChildren[i], dom);\n        }\n    }\n}\nfunction patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {\n    var aEnd = aLength - 1;\n    var bEnd = bLength - 1;\n    var j = 0;\n    var aNode = a[j];\n    var bNode = b[j];\n    var nextPos;\n    var nextNode;\n    // Step 1\n    // tslint:disable-next-line\n    outer: {\n        // Sync nodes with the same key at the beginning.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[j] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[j] = bNode;\n            ++j;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[j];\n            bNode = b[j];\n        }\n        aNode = a[aEnd];\n        bNode = b[bEnd];\n        // Sync nodes with the same key at the end.\n        while (aNode.key === bNode.key) {\n            if (bNode.flags & 16384 /* InUse */) {\n                b[bEnd] = bNode = directClone(bNode);\n            }\n            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n            a[aEnd] = bNode;\n            aEnd--;\n            bEnd--;\n            if (j > aEnd || j > bEnd) {\n                break outer;\n            }\n            aNode = a[aEnd];\n            bNode = b[bEnd];\n        }\n    }\n    if (j > aEnd) {\n        if (j <= bEnd) {\n            nextPos = bEnd + 1;\n            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;\n            while (j <= bEnd) {\n                bNode = b[j];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[j] = bNode = directClone(bNode);\n                }\n                ++j;\n                mount(bNode, dom, context, isSVG, nextNode, lifecycle);\n            }\n        }\n    }\n    else if (j > bEnd) {\n        while (j <= aEnd) {\n            remove(a[j++], dom);\n        }\n    }\n    else {\n        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);\n    }\n}\nfunction patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {\n    var aNode;\n    var bNode;\n    var nextPos;\n    var i = 0;\n    var aStart = j;\n    var bStart = j;\n    var aLeft = aEnd - j + 1;\n    var bLeft = bEnd - j + 1;\n    var sources = new Int32Array(bLeft + 1);\n    // Keep track if its possible to remove whole DOM using textContent = '';\n    var canRemoveWholeContent = aLeft === aLength;\n    var moved = false;\n    var pos = 0;\n    var patched = 0;\n    // When sizes are small, just loop them through\n    if (bLength < 4 || (aLeft | bLeft) < 32) {\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                for (j = bStart; j <= bEnd; j++) {\n                    bNode = b[j];\n                    if (aNode.key === bNode.key) {\n                        sources[j - bStart] = i + 1;\n                        if (canRemoveWholeContent) {\n                            canRemoveWholeContent = false;\n                            while (aStart < i) {\n                                remove(a[aStart++], dom);\n                            }\n                        }\n                        if (pos > j) {\n                            moved = true;\n                        }\n                        else {\n                            pos = j;\n                        }\n                        if (bNode.flags & 16384 /* InUse */) {\n                            b[j] = bNode = directClone(bNode);\n                        }\n                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                        ++patched;\n                        break;\n                    }\n                }\n                if (!canRemoveWholeContent && j > bEnd) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    else {\n        var keyIndex = {};\n        // Map keys by their index\n        for (i = bStart; i <= bEnd; ++i) {\n            keyIndex[b[i].key] = i;\n        }\n        // Try to patch same keys\n        for (i = aStart; i <= aEnd; ++i) {\n            aNode = a[i];\n            if (patched < bLeft) {\n                j = keyIndex[aNode.key];\n                if (j !== void 0) {\n                    if (canRemoveWholeContent) {\n                        canRemoveWholeContent = false;\n                        while (i > aStart) {\n                            remove(a[aStart++], dom);\n                        }\n                    }\n                    sources[j - bStart] = i + 1;\n                    if (pos > j) {\n                        moved = true;\n                    }\n                    else {\n                        pos = j;\n                    }\n                    bNode = b[j];\n                    if (bNode.flags & 16384 /* InUse */) {\n                        b[j] = bNode = directClone(bNode);\n                    }\n                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);\n                    ++patched;\n                }\n                else if (!canRemoveWholeContent) {\n                    remove(aNode, dom);\n                }\n            }\n            else if (!canRemoveWholeContent) {\n                remove(aNode, dom);\n            }\n        }\n    }\n    // fast-path: if nothing patched remove all old and add all new\n    if (canRemoveWholeContent) {\n        removeAllChildren(dom, parentVNode, a);\n        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);\n    }\n    else if (moved) {\n        var seq = lis_algorithm(sources);\n        j = seq.length - 1;\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n            else if (j < 0 || i !== seq[j]) {\n                pos = i + bStart;\n                bNode = b[pos];\n                nextPos = pos + 1;\n                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);\n            }\n            else {\n                j--;\n            }\n        }\n    }\n    else if (patched !== bLeft) {\n        // when patched count doesn't match b length we need to insert those new ones\n        // loop backwards so we can use insertBefore\n        for (i = bLeft - 1; i >= 0; i--) {\n            if (sources[i] === 0) {\n                pos = i + bStart;\n                bNode = b[pos];\n                if (bNode.flags & 16384 /* InUse */) {\n                    b[pos] = bNode = directClone(bNode);\n                }\n                nextPos = pos + 1;\n                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);\n            }\n        }\n    }\n}\nvar result;\nvar p;\nvar maxLen = 0;\n// https://en.wikipedia.org/wiki/Longest_increasing_subsequence\nfunction lis_algorithm(arr) {\n    var arrI = 0;\n    var i = 0;\n    var j = 0;\n    var k = 0;\n    var u = 0;\n    var v = 0;\n    var c = 0;\n    var len = arr.length;\n    if (len > maxLen) {\n        maxLen = len;\n        result = new Int32Array(len);\n        p = new Int32Array(len);\n    }\n    for (; i < len; ++i) {\n        arrI = arr[i];\n        if (arrI !== 0) {\n            j = result[k];\n            if (arr[j] < arrI) {\n                p[i] = j;\n                result[++k] = i;\n                continue;\n            }\n            u = 0;\n            v = k;\n            while (u < v) {\n                c = (u + v) >> 1;\n                if (arr[result[c]] < arrI) {\n                    u = c + 1;\n                }\n                else {\n                    v = c;\n                }\n            }\n            if (arrI < arr[result[u]]) {\n                if (u > 0) {\n                    p[i] = result[u - 1];\n                }\n                result[u] = i;\n            }\n        }\n    }\n    u = k + 1;\n    var seq = new Int32Array(u);\n    v = result[u - 1];\n    while (u-- > 0) {\n        seq[u] = v;\n        v = p[v];\n        result[u] = 0;\n    }\n    return seq;\n}\n\nvar hasDocumentAvailable = typeof document !== 'undefined';\nif (hasDocumentAvailable) {\n    /*\n     * Defining $EV and $V properties on Node.prototype\n     * fixes v8 \"wrong map\" de-optimization\n     */\n    if (window.Node) {\n        Node.prototype.$EV = null;\n        Node.prototype.$V = null;\n    }\n}\nfunction __render(input, parentDOM, callback, context) {\n    var lifecycle = [];\n    var rootInput = parentDOM.$V;\n    renderCheck.v = true;\n    if (isNullOrUndef(rootInput)) {\n        if (!isNullOrUndef(input)) {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            mount(input, parentDOM, context, false, null, lifecycle);\n            parentDOM.$V = input;\n            rootInput = input;\n        }\n    }\n    else {\n        if (isNullOrUndef(input)) {\n            remove(rootInput, parentDOM);\n            parentDOM.$V = null;\n        }\n        else {\n            if (input.flags & 16384 /* InUse */) {\n                input = directClone(input);\n            }\n            patch(rootInput, input, parentDOM, context, false, null, lifecycle);\n            rootInput = parentDOM.$V = input;\n        }\n    }\n    callAll(lifecycle);\n    renderCheck.v = false;\n    if (isFunction(callback)) {\n        callback();\n    }\n    if (isFunction(options.renderComplete)) {\n        options.renderComplete(rootInput, parentDOM);\n    }\n}\nfunction render(input, parentDOM, callback, context) {\n    if ( callback === void 0 ) callback = null;\n    if ( context === void 0 ) context = EMPTY_OBJ;\n\n    __render(input, parentDOM, callback, context);\n}\nfunction createRenderer(parentDOM) {\n    return function renderer(lastInput, nextInput, callback, context) {\n        if (!parentDOM) {\n            parentDOM = lastInput;\n        }\n        render(nextInput, parentDOM, callback, context);\n    };\n}\n\nvar QUEUE = [];\nvar nextTick = typeof Promise !== 'undefined'\n    ? Promise.resolve().then.bind(Promise.resolve())\n    : function (a) {\n        window.setTimeout(a, 0);\n    };\nvar microTaskPending = false;\nfunction queueStateChanges(component, newState, callback, force) {\n    var pending = component.$PS;\n    if (isFunction(newState)) {\n        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);\n    }\n    if (isNullOrUndef(pending)) {\n        component.$PS = newState;\n    }\n    else {\n        for (var stateKey in newState) {\n            pending[stateKey] = newState[stateKey];\n        }\n    }\n    if (!component.$BR) {\n        if (!renderCheck.v) {\n            if (QUEUE.length === 0) {\n                applyState(component, force);\n                if (isFunction(callback)) {\n                    callback.call(component);\n                }\n                return;\n            }\n        }\n        if (QUEUE.indexOf(component) === -1) {\n            QUEUE.push(component);\n        }\n        if (force) {\n            component.$F = true;\n        }\n        if (!microTaskPending) {\n            microTaskPending = true;\n            nextTick(rerender);\n        }\n        if (isFunction(callback)) {\n            var QU = component.$QU;\n            if (!QU) {\n                QU = component.$QU = [];\n            }\n            QU.push(callback);\n        }\n    }\n    else if (isFunction(callback)) {\n        component.$L.push(callback.bind(component));\n    }\n}\nfunction callSetStateCallbacks(component) {\n    var queue = component.$QU;\n    for (var i = 0; i < queue.length; ++i) {\n        queue[i].call(component);\n    }\n    component.$QU = null;\n}\nfunction rerender() {\n    var component;\n    microTaskPending = false;\n    while ((component = QUEUE.shift())) {\n        if (!component.$UN) {\n            var force = component.$F;\n            component.$F = false;\n            applyState(component, force);\n            if (component.$QU) {\n                callSetStateCallbacks(component);\n            }\n        }\n    }\n}\nfunction applyState(component, force) {\n    if (force || !component.$BR) {\n        var pendingState = component.$PS;\n        component.$PS = null;\n        var lifecycle = [];\n        renderCheck.v = true;\n        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);\n        callAll(lifecycle);\n        renderCheck.v = false;\n    }\n    else {\n        component.state = component.$PS;\n        component.$PS = null;\n    }\n}\nvar Component = function Component(props, context) {\n    // Public\n    this.state = null;\n    // Internal properties\n    this.$BR = false; // BLOCK RENDER\n    this.$BS = true; // BLOCK STATE\n    this.$PS = null; // PENDING STATE (PARTIAL or FULL)\n    this.$LI = null; // LAST INPUT\n    this.$UN = false; // UNMOUNTED\n    this.$CX = null; // CHILDCONTEXT\n    this.$QU = null; // QUEUE\n    this.$N = false; // Uses new lifecycle API Flag\n    this.$L = null; // Current lifecycle of this component\n    this.$SVG = false; // Flag to keep track if component is inside SVG tree\n    this.$F = false; // Force update flag\n    this.props = props || EMPTY_OBJ;\n    this.context = context || EMPTY_OBJ; // context should not be mutable\n};\nComponent.prototype.forceUpdate = function forceUpdate (callback) {\n    if (this.$UN) {\n        return;\n    }\n    // Do not allow double render during force update\n    queueStateChanges(this, {}, callback, true);\n};\nComponent.prototype.setState = function setState (newState, callback) {\n    if (this.$UN) {\n        return;\n    }\n    if (!this.$BS) {\n        queueStateChanges(this, newState, callback, false);\n    }\n};\nComponent.prototype.render = function render (_nextProps, _nextState, _nextContext) {\n    return null;\n};\n\nvar version = \"7.4.11\";\n\nexport { Component, EMPTY_OBJ, Fragment, createClassComponentInstance as _CI, normalizeRoot as _HI, mount as _M, mountClassComponentCallbacks as _MCCC, mountElement as _ME, mountFunctionalComponentCallbacks as _MFCC, mountProps as _MP, mountRef as _MR, renderFunctionalComponent as _RFC, __render, createComponentVNode, createFragment, createPortal, createRef, createRenderer, createTextVNode, createVNode, directClone, findDOMfromVNode, forwardRef, getFlagsForElementVnode, linkEvent, normalizeProps, options, render, rerender, version };\n"]},"metadata":{},"sourceType":"module"}